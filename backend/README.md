# Sistema de Gerenciamento Escolar (SGE) - Back-end

## Autor:
**Rafael Vitor de Oliveira** - *Desenvolvedor de Software*

- [LinkedIn](https://www.linkedin.com/in/rafaelvitor2/)  
- [GitHub](https://github.com/rafaeldgdf)  
- **E-mail:** [rafaelvd2@hotmail.com](mailto:rafaelvd2@hotmail.com)

Eu, **Rafael Vitor de Oliveira**, fui responsável por todo o desenvolvimento do **back-end** deste projeto, que abrange a **lógica de negócios**, **integração de banco de dados**, e o **deploy da aplicação**. O projeto continuará em desenvolvimento por colegas de equipe, especialmente na implementação do **front-end** e em **testes de integração**.

---

## Introdução

O **Sistema de Gerenciamento Escolar (SGE)** é uma solução desenvolvida como parte do **Projeto Integrador III** do curso de **Análise e Desenvolvimento de Sistemas** na **Faculdade Senac Pernambuco**. Este sistema tem como objetivo modernizar e centralizar o gerenciamento acadêmico do **Mediotec**, um curso técnico integrado ao ensino médio, também ofertado pelo **Senac**. O **SGE** visa automatizar e otimizar diversos processos internos da escola, que até o momento são realizados manualmente.

Com essa solução, é possível centralizar o controle de **turmas**, **disciplinas**, **professores**, **alunos**, e avaliar o **desempenho acadêmico**, além de possibilitar uma comunicação mais eficiente entre a administração e os demais stakeholders, como professores e coordenadores.

---

## Objetivo do Projeto

O **SGE** tem como propósito principal ser uma ferramenta integrada que automatize a gestão escolar do **Mediotec**. Contudo, o projeto vai além de um simples sistema de cadastro e controle. Ele é capaz de:

- **Gerenciar alunos, professores, turmas e disciplinas** de maneira eficiente.
- **Registrar e acompanhar o desempenho acadêmico** de cada aluno, com possibilidade de emitir boletins de notas e conceitos.
- **Facilitar a comunicação interna** entre professores, coordenadores e estudantes por meio de comunicados e alertas.
- **Permitir o acompanhamento de presença e frequência** dos alunos, integrando dados em tempo real.
- **Oferecer relatórios gerenciais** para coordenadores, como estatísticas de desempenho e frequência.

O **SGE** é flexível e escalável, pronto para receber novos módulos e funcionalidades, de acordo com as demandas da instituição.

---

## Tecnologias Utilizadas

O sistema foi projetado com foco em **desempenho** e **escalabilidade**, utilizando um conjunto moderno de tecnologias:

- **Java com Spring Boot:** Para o desenvolvimento da lógica de negócios e gerenciamento das requisições.
- **MySQL:** Como banco de dados relacional para o armazenamento e recuperação de informações.
- **JPA/Hibernate:** Para o mapeamento objeto-relacional (ORM) e simplificação da interação com o banco de dados.
- **Swagger/OpenAPI:** Para a documentação interativa da API, facilitando a integração e testes.
- **Heroku:** A aplicação está atualmente **hospedada no Heroku**, permitindo que qualquer usuário possa acessar e fazer requisições à API via HTTPS.

---

## Acesso Público

A **API do SGE** está disponível publicamente e pode ser acessada diretamente por qualquer usuário através do seguinte link:

[Swagger UI do SGE](https://projeto-mediotec-128688b099aa.herokuapp.com/swagger-ui/index.html)

Com essa interface, é possível explorar e testar as funcionalidades da API sem a necessidade de configurar localmente.

---

## Estrutura do Back-end e Banco de Dados

O **SGE** foi construído para garantir uma **estrutura sólida** e **modular** que permita futuras expansões:

- **Entidades robustas** foram modeladas para representar as principais operações escolares, com suas respectivas regras de negócio.
- O sistema foi projetado para suportar a **persistência de dados** por meio de transações seguras com o banco de dados **MySQL**.
- A arquitetura do back-end está pronta para futuras integrações com o **front-end** e **aplicações móveis**, proporcionando uma experiência unificada para todos os usuários.

---

## IA Personalizada para Suporte ao Projeto

Um diferencial importante do projeto **SGE** é a **IA personalizada**, que está disponível publicamente para auxiliar qualquer pessoa com dúvidas relacionadas ao projeto. Essa IA foi configurada e treinada com todos os comandos e funcionalidades do sistema, estando pronta para responder perguntas técnicas e fornecer suporte em tempo real. Qualquer pessoa pode acessar a IA via o link abaixo:

[Acessar IA Personalizada para o Projeto SGE](https://chatgpt.com/g/g-gGPh7ItKn-projeto-mediotec)

Essa ferramenta adicional permitirá que **usuários**, **desenvolvedores** e **interessados no projeto** obtenham respostas rápidas e precisas sobre o funcionamento do sistema e seus comandos.

---

## Colaboração e Futuras Integrações

O projeto **SGE** é parte de uma solução colaborativa e integrada, onde cada fase é essencial para proporcionar uma **experiência completa** de gestão escolar. Com a primeira fase já concluída, que envolveu o desenvolvimento e publicação do **back-end**, a continuidade do projeto está nas mãos dos **meus colegas de equipe**, que serão responsáveis pela criação de um **front-end moderno e responsivo**. Eles desenvolverão uma **Progressive Web App (PWA)**, assegurando uma interface de alta performance que se adapta perfeitamente a **dispositivos móveis** e **desktops**, oferecendo uma experiência de uso contínua, independente da plataforma utilizada.

Além disso, meus colegas também se dedicarão à **documentação completa das regras de negócios** do sistema, garantindo que todos os processos sejam devidamente registrados. Eles também liderarão a **integração entre o front-end e o back-end**, assegurando que todas as funcionalidades trabalhem de forma harmoniosa, resultando em um sistema coeso e eficiente.

### Próximos Passos:

- **Desenvolvimento do Front-end web e mobile:** Utilizando frameworks modernos como **React.js** ou **Vue.js**.
- **Testes Funcionais e de Integração:** Para garantir a usabilidade e funcionamento correto entre as interfaces gráficas e o back-end.
- **Segurança e Melhorias:** Implementação de mecanismos avançados de segurança, como **Spring Security**, e melhorias contínuas no tratamento de erros.
- **Integração com APIs Externas:** Futuras integrações com sistemas de ensino à distância, gerenciadores de conteúdo e sistemas de pagamento.

---


# Sumário
- [Sistema de Gerenciamento Escolar (SGE) - Back-end](#Sistema-de-Gerenciamento-Escolar-(SGE)---Back-end)
  - [Autor:](#Autor:)
  - [Introdução](#Introdução)
  - [Objetivo do Projeto](#Objetivo-do-Projeto)
  - [Tecnologias Utilizadas](#Tecnologias-Utilizadas)
  - [Acesso Público](#Acesso-Público)
  - [Estrutura do Back-end e Banco de Dados](#Estrutura-do-Back-end-e-Banco-de-Dados)
  - [IA Personalizada para Suporte ao Projeto](#IA-Personalizada-para-Suporte-ao-Projeto)
  - [Colaboração e Futuras Integrações](#Colaboração-e-Futuras-Integrações)
    - [Próximos Passos:](#Próximos-Passos:)
- [Capítulo 1 - Estrutura Geral dos Pacotes no Sistema SGE](#Capítulo-1---Estrutura-Geral-dos-Pacotes-no-Sistema-SGE)
  - [Estrutura dos Pacotes](#Estrutura-dos-Pacotes)
  - [Explicação da Estrutura](#Explicação-da-Estrutura)
  - [Modularidade](#Modularidade)
- [Entidades no Sistema SGE](#Entidades-no-Sistema-SGE)
  - [O que são Entidades?](#O-que-são-Entidades?)
  - [Estrutura e Funcionalidades no Java, Spring e SGE](#Estrutura-e-Funcionalidades-no-Java,-Spring-e-SGE)
  - [O que é JPA?](#O-que-é-JPA?)
    - [Funcionalidades da JPA](#Funcionalidades-da-JPA)
  - [Uso do Lombok nas Entidades](#Uso-do-Lombok-nas-Entidades)
    - [Principais Anotações do Lombok](#Principais-Anotações-do-Lombok)
  - [Anotações Comuns da JPA](#Anotações-Comuns-da-JPA)
  - [Exemplo de Entidade com JPA e Lombok: `Aluno.java`](#Exemplo-de-Entidade-com-JPA-e-Lombok:-`Aluno.java`)
  - [Relacionamentos Entre Entidades](#Relacionamentos-Entre-Entidades)
    - [Exemplo de Relacionamento](#Exemplo-de-Relacionamento)
  - [Anotações para Validação](#Anotações-para-Validação)
    - [Exemplo de validação em atributos da entidade `Aluno`:](#Exemplo-de-validação-em-atributos-da-entidade-`Aluno`:)
  - [Métodos Auxiliares](#Métodos-Auxiliares)
  - [Resumo: Importância das Entidades, JPA e Lombok no SGE](#Resumo:-Importância-das-Entidades,-JPA-e-Lombok-no-SGE)
    - [Benefícios](#Benefícios)
- [Repositórios no Sistema SGE](#Repositórios-no-Sistema-SGE)
  - [O que são Repositórios?](#O-que-são-Repositórios?)
  - [Estrutura e Funcionalidade no Java, Spring e SGE](#Estrutura-e-Funcionalidade-no-Java,-Spring-e-SGE)
  - [Principais Anotações e Funcionalidades](#Principais-Anotações-e-Funcionalidades)
  - [Exemplo de Interface de Repositório](#Exemplo-de-Interface-de-Repositório)
  - [Métodos Comuns Herdados de JpaRepository](#Métodos-Comuns-Herdados-de-JpaRepository)
  - [Consultas Personalizadas](#Consultas-Personalizadas)
    - [Exemplo de Consulta Personalizada](#Exemplo-de-Consulta-Personalizada)
    - [Exemplo de Consulta com @Query](#Exemplo-de-Consulta-com-@Query)
  - [Injeção de Dependências](#Injeção-de-Dependências)
    - [Exemplo de Injeção de Dependências](#Exemplo-de-Injeção-de-Dependências)
  - [Resumo: Importância dos Repositórios no SGE](#Resumo:-Importância-dos-Repositórios-no-SGE)
    - [Benefícios](#Benefícios)
- [Serviços no Sistema SGE](#Serviços-no-Sistema-SGE)
  - [O que são Serviços?](#O-que-são-Serviços?)
  - [Estrutura e Funcionalidades no Java, Spring e SGE](#Estrutura-e-Funcionalidades-no-Java,-Spring-e-SGE)
  - [Principais Anotações e Funcionalidades](#Principais-Anotações-e-Funcionalidades)
  - [Métodos Comuns em Serviços](#Métodos-Comuns-em-Serviços)
    - [1. Métodos CRUD (Create, Read, Update, Delete)](#1.-Métodos-CRUD-(Create,-Read,-Update,-Delete))
      - [Criação de uma Entidade (Create)](#Criação-de-uma-Entidade-(Create))
        - [Exemplo:](#Exemplo:)
      - [Busca de Dados (Read)](#Busca-de-Dados-(Read))
        - [Exemplo:](#Exemplo:)
      - [Atualização de uma Entidade (Update)](#Atualização-de-uma-Entidade-(Update))
        - [Exemplo:](#Exemplo:)
      - [Deleção de uma Entidade (Delete)](#Deleção-de-uma-Entidade-(Delete))
        - [Exemplo:](#Exemplo:)
    - [2. Validações e Regras de Negócio](#2.-Validações-e-Regras-de-Negócio)
      - [Exemplo de Regra de Negócio:](#Exemplo-de-Regra-de-Negócio:)
    - [3. Métodos Específicos](#3.-Métodos-Específicos)
      - [Exemplo:](#Exemplo:)
    - [4. Métodos de Conversão (DTOs)](#4.-Métodos-de-Conversão-(DTOs))
      - [Exemplo:](#Exemplo:)
  - [Resumo: Importância dos Serviços no SGE](#Resumo:-Importância-dos-Serviços-no-SGE)
    - [Benefícios:](#Benefícios:)
- [DTOs no Sistema SGE](#DTOs-no-Sistema-SGE)
  - [O que são DTOs?](#O-que-são-DTOs?)
  - [Estrutura e Funcionalidade no Java, Spring e SGE](#Estrutura-e-Funcionalidade-no-Java,-Spring-e-SGE)
    - [Quando Utilizar DTOs](#Quando-Utilizar-DTOs)
  - [Criação de DTOs no Sistema](#Criação-de-DTOs-no-Sistema)
    - [Estrutura Simples de um DTO](#Estrutura-Simples-de-um-DTO)
    - [Exemplo de DTO para a Entidade Aluno](#Exemplo-de-DTO-para-a-Entidade-Aluno)
    - [Como o DTO Funciona:](#Como-o-DTO-Funciona:)
  - [Conversão Entre DTOs e Entidades](#Conversão-Entre-DTOs-e-Entidades)
    - [Exemplo de Conversão Entre DTO e Entidade](#Exemplo-de-Conversão-Entre-DTO-e-Entidade)
    - [Conversão de DTO para Entidade](#Conversão-de-DTO-para-Entidade)
    - [Conversão de Entidade para DTO](#Conversão-de-Entidade-para-DTO)
  - [Vantagens do Uso de DTOs](#Vantagens-do-Uso-de-DTOs)
  - [Resumo: Importância dos DTOs no SGE](#Resumo:-Importância-dos-DTOs-no-SGE)
    - [Benefícios:](#Benefícios:)
- [Controladores (Controllers) no Sistema SGE](#Controladores-(Controllers)-no-Sistema-SGE)
  - [O que são Controladores?](#O-que-são-Controladores?)
  - [Estrutura e Funcionalidade no Java, Spring e SGE](#Estrutura-e-Funcionalidade-no-Java,-Spring-e-SGE)
  - [Principais Anotações e Funcionalidades](#Principais-Anotações-e-Funcionalidades)
  - [Exemplos de Métodos Comuns em Controladores](#Exemplos-de-Métodos-Comuns-em-Controladores)
    - [1. Buscar Todos os Alunos (GET)](#1.-Buscar-Todos-os-Alunos-(GET))
    - [2. Buscar Aluno por ID (GET)](#2.-Buscar-Aluno-por-ID-(GET))
    - [3. Criar Novo Aluno (POST)](#3.-Criar-Novo-Aluno-(POST))
    - [4. Atualizar Aluno (PUT)](#4.-Atualizar-Aluno-(PUT))
    - [5. Deletar Aluno (DELETE)](#5.-Deletar-Aluno-(DELETE))
  - [Tratamento de Erros nos Controladores](#Tratamento-de-Erros-nos-Controladores)
  - [Resumo: Importância dos Controladores no SGE](#Resumo:-Importância-dos-Controladores-no-SGE)
    - [Benefícios:](#Benefícios:)
- [Capítulo 2 - Explicação dos Pacotes](#Capítulo-2---Explicação-dos-Pacotes)
  - [Estrutura Geral](#Estrutura-Geral)
- [Package aluno](#Package-aluno)
    - [Aluno.java (Entidade)](#Aluno.java-(Entidade))
    - [AlunoRepository.java (Repositório)](#AlunoRepository.java-(Repositório))
    - [AlunoService.java (Serviço)](#AlunoService.java-(Serviço))
    - [AlunoDTO.java (DTO)](#AlunoDTO.java-(DTO))
    - [AlunoResumidoDTO.java (DTO)](#AlunoResumidoDTO.java-(DTO))
    - [AlunoResumidoDTO2.java (DTO)](#AlunoResumidoDTO2.java-(DTO))
    - [AlunoReduzidoDTO.java (DTO)](#AlunoReduzidoDTO.java-(DTO))
    - [AlunoController.java (Controlador)](#AlunoController.java-(Controlador))
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
  - [Conclusão](#Conclusão)
- [Package comunicado](#Package-comunicado)
    - [Comunicado.java (Entidade)](#Comunicado.java-(Entidade))
    - [ComunicadoRepository.java (Repositório)](#ComunicadoRepository.java-(Repositório))
    - [ComunicadoService.java (Serviço)](#ComunicadoService.java-(Serviço))
    - [ComunicadoDTO.java (DTO)](#ComunicadoDTO.java-(DTO))
    - [ComunicadoController.java (Controlador)](#ComunicadoController.java-(Controlador))
    - [Rotas (Endpoints):](#Rotas-(Endpoints):)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
      - [GET](#GET)
    - [Tratamento de Erros:](#Tratamento-de-Erros:)
  - [Conclusão](#Conclusão)
- [Package conceito](#Package-conceito)
    - [Conceito.java (Entidade)](#Conceito.java-(Entidade))
    - [ConceitoRepository.java (Repositório)](#ConceitoRepository.java-(Repositório))
    - [ConceitoService.java (Serviço)](#ConceitoService.java-(Serviço))
  - [Anotações:](#Anotações:)
  - [Métodos CRUD:](#Métodos-CRUD:)
  - [Cálculos de Notas e Regras de Negócio](#Cálculos-de-Notas-e-Regras-de-Negócio)
    - [1. Cálculo das Notas de Recuperação: NOA1 e NOA2](#1.-Cálculo-das-Notas-de-Recuperação:-NOA1-e-NOA2)
      - [Regras de Substituição:](#Regras-de-Substituição:)
      - [Exemplo de Substituição:](#Exemplo-de-Substituição:)
    - [2. Cálculo da Média Final](#2.-Cálculo-da-Média-Final)
    - [3. NOA Final: Recuperação Final](#3.-NOA-Final:-Recuperação-Final)
      - [Regras para Uso do NOA Final:](#Regras-para-Uso-do-NOA-Final:)
      - [Exemplo de Aplicação:](#Exemplo-de-Aplicação:)
    - [4. Critérios de Aprovação e Reprovação](#4.-Critérios-de-Aprovação-e-Reprovação)
      - [Aprovação com NOA Final:](#Aprovação-com-NOA-Final:)
    - [5. Implementação dos Cálculos no Sistema](#5.-Implementação-dos-Cálculos-no-Sistema)
    - [Conceitos Descritivos:](#Conceitos-Descritivos:)
    - [ConceitoController.java (Controlador)](#ConceitoController.java-(Controlador))
    - [Rotas (Endpoints):](#Rotas-(Endpoints):)
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
    - [Tratamento de Erros:](#Tratamento-de-Erros:)
  - [Conclusão](#Conclusão)
- [Package coordenacao](#Package-coordenacao)
    - [Coordenacao.java (Entidade)](#Coordenacao.java-(Entidade))
    - [Métodos Auxiliares](#Métodos-Auxiliares)
      - [addEndereco(Endereco endereco)](#addEndereco(Endereco-endereco))
      - [addTelefone(Telefone telefone)](#addTelefone(Telefone-telefone))
      - [addCoordenador(Coordenador coordenador)](#addCoordenador(Coordenador-coordenador))
      - [addTurma(Turma turma)](#addTurma(Turma-turma))
      - [addProfessor(Professor professor)](#addProfessor(Professor-professor))
    - [CoordenacaoRepository.java (Repositório)](#CoordenacaoRepository.java-(Repositório))
    - [CoordenacaoService.java (Serviço)](#CoordenacaoService.java-(Serviço))
    - [CoordenacaoDTO.java e CoordenacaoCadastroDTO.java (DTOs)](#CoordenacaoDTO.java-e-CoordenacaoCadastroDTO.java-(DTOs))
    - [CoordenacaoController.java (Controlador)](#CoordenacaoController.java-(Controlador))
    - [Rotas (Endpoints):](#Rotas-(Endpoints):)
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
    - [Tratamento de Erros:](#Tratamento-de-Erros:)
  - [Conclusão](#Conclusão)
- [Package coordenador](#Package-coordenador)
    - [Coordenador.java (Entidade)](#Coordenador.java-(Entidade))
    - [CoordenadorRepository.java (Repositório)](#CoordenadorRepository.java-(Repositório))
    - [CoordenadorService.java (Serviço)](#CoordenadorService.java-(Serviço))
    - [CoordenadorDTO.java (DTO)](#CoordenadorDTO.java-(DTO))
    - [CoordenadorController.java (Controlador)](#CoordenadorController.java-(Controlador))
    - [Rotas (Endpoints):](#Rotas-(Endpoints):)
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
  - [Conclusão](#Conclusão)
- [Package Disciplina](#Package-Disciplina)
  - [Entidade Disciplina.java](#Entidade-Disciplina.java)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Relacionamentos](#Relacionamentos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [DisciplinaRepository.java (Repositório)](#DisciplinaRepository.java-(Repositório))
    - [Métodos](#Métodos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [DisciplinaService.java (Serviço)](#DisciplinaService.java-(Serviço))
    - [Métodos](#Métodos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [DTOs](#DTOs)
    - [DisciplinaDTO (Data Transfer Object)](#DisciplinaDTO-(Data-Transfer-Object))
    - [DisciplinaGetDTO](#DisciplinaGetDTO)
    - [DisciplinaResumidaDTO](#DisciplinaResumidaDTO)
  - [DisciplinaController.java (Controlador)](#DisciplinaController.java-(Controlador))
    - [Rotas (Endpoints)](#Rotas-(Endpoints))
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
  - [Tratamento de Erros](#Tratamento-de-Erros)
  - [Conclusão](#Conclusão)
- [Package Endereco](#Package-Endereco)
    - [Estrutura do Package](#Estrutura-do-Package)
  - [Entidade Endereco.java](#Entidade-Endereco.java)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Relacionamentos](#Relacionamentos)
    - [Regras de Negócio](#Regras-de-Negócio)
    - [Métodos Importantes](#Métodos-Importantes)
  - [EnderecoDTO.java (Data Transfer Object)](#EnderecoDTO.java-(Data-Transfer-Object))
    - [Anotações](#Anotações)
    - [Atributos](#Atributos)
    - [Utilização](#Utilização)
- [Package presencas](#Package-presencas)
  - [Presenca.java (Entidade)](#Presenca.java-(Entidade))
    - [Anotações:](#Anotações:)
    - [Relacionamentos:](#Relacionamentos:)
    - [Atributos Principais:](#Atributos-Principais:)
    - [Regras de Negócio:](#Regras-de-Negócio:)
  - [PresencaRepository.java (Repositório)](#PresencaRepository.java-(Repositório))
    - [Métodos:](#Métodos:)
    - [Regras de Negócio:](#Regras-de-Negócio:)
  - [PresencaService.java (Serviço)](#PresencaService.java-(Serviço))
    - [Anotações:](#Anotações:)
    - [Métodos:](#Métodos:)
      - [Regras de Negócio:](#Regras-de-Negócio:)
  - [PresencaController.java (Controlador)](#PresencaController.java-(Controlador))
    - [Anotações:](#Anotações:)
    - [Rotas (Endpoints):](#Rotas-(Endpoints):)
      - [Validações:](#Validações:)
      - [Validações:](#Validações:)
      - [Validações:](#Validações:)
      - [Validações:](#Validações:)
    - [Tratamento de Erros:](#Tratamento-de-Erros:)
  - [Considerações Finais](#Considerações-Finais)
- [Package Professor](#Package-Professor)
    - [Este package contém as principais classes:](#Este-package-contém-as-principais-classes:)
  - [Entidade Professor.java](#Entidade-Professor.java)
    - [Atributos Principais](#Atributos-Principais)
    - [Relacionamentos](#Relacionamentos)
- [ProfessorRepository.java (Repositório)](#ProfessorRepository.java-(Repositório))
  - [Métodos](#Métodos)
  - [Regras de Negócio](#Regras-de-Negócio)
  - [ProfessorService.java (Serviço)](#ProfessorService.java-(Serviço))
    - [Métodos Principais](#Métodos-Principais)
    - [Métodos Auxiliares](#Métodos-Auxiliares)
  - [ProfessorController.java (Controlador)](#ProfessorController.java-(Controlador))
    - [Endpoints Principais](#Endpoints-Principais)
  - [Métodos Relacionados a Conceitos](#Métodos-Relacionados-a-Conceitos)
  - [Considerações Finais](#Considerações-Finais)
- [Package Responsável](#Package-Responsável)
  - [Estrutura do Package](#Estrutura-do-Package)
  - [Entidade Responsavel.java](#Entidade-Responsavel.java)
    - [Atributos Principais](#Atributos-Principais)
    - [Relacionamentos](#Relacionamentos)
    - [Métodos Auxiliares](#Métodos-Auxiliares)
    - [Exemplo de Relacionamento com Aluno](#Exemplo-de-Relacionamento-com-Aluno)
    - [Exemplo de Relacionamento com Telefones](#Exemplo-de-Relacionamento-com-Telefones)
  - [ResponsavelDTO.java (Data Transfer Object)](#ResponsavelDTO.java-(Data-Transfer-Object))
    - [Atributos Principais](#Atributos-Principais)
  - [Considerações Finais](#Considerações-Finais)
- [Package Telefone](#Package-Telefone)
  - [Estrutura do Package](#Estrutura-do-Package)
  - [Entidade Telefone.java](#Entidade-Telefone.java)
    - [Atributos Principais](#Atributos-Principais)
    - [Validações](#Validações)
    - [Relacionamentos](#Relacionamentos)
    - [Entidades Relacionadas](#Entidades-Relacionadas)
  - [Métodos Auxiliares](#Métodos-Auxiliares)
  - [TelefoneDTO.java (Data Transfer Object)](#TelefoneDTO.java-(Data-Transfer-Object))
    - [Atributos Principais](#Atributos-Principais)
  - [Considerações Finais](#Considerações-Finais)
- [Package Turma](#Package-Turma)
  - [Entidade Turma.java](#Entidade-Turma.java)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Relacionamentos](#Relacionamentos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [TurmaRepository.java (Repositório)](#TurmaRepository.java-(Repositório))
    - [Métodos](#Métodos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [TurmaService.java (Serviço)](#TurmaService.java-(Serviço))
    - [Métodos](#Métodos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [DTOs](#DTOs)
    - [TurmaDTO (Data Transfer Object)](#TurmaDTO-(Data-Transfer-Object))
    - [Atributos](#Atributos)
    - [TurmaInputDTO](#TurmaInputDTO)
    - [Atributos](#Atributos)
    - [DisciplinaProfessorDTO](#DisciplinaProfessorDTO)
    - [Atributos](#Atributos)
  - [TurmaController.java (Controlador)](#TurmaController.java-(Controlador))
    - [Rotas (Endpoints)](#Rotas-(Endpoints))
      - [GET](#GET)
      - [POST](#POST)
      - [PUT](#PUT)
      - [DELETE](#DELETE)
    - [Tratamento de Erros](#Tratamento-de-Erros)
  - [Conclusão](#Conclusão)
- [Package TurmaDisciplinaProfessor](#Package-TurmaDisciplinaProfessor)
  - [Entidade TurmaDisciplinaProfessor.java](#Entidade-TurmaDisciplinaProfessor.java)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [Classe TurmaDisciplinaProfessorId.java](#Classe-TurmaDisciplinaProfessorId.java)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [DTOs](#DTOs)
    - [TurmaDisciplinaProfessorDTO.java](#TurmaDisciplinaProfessorDTO.java)
      - [Atributos:](#Atributos:)
    - [TurmaDisciplinaProfessorIdDTO.java](#TurmaDisciplinaProfessorIdDTO.java)
      - [Atributos:](#Atributos:)
    - [TurmaDisciplinaProfessorCompletoDTO.java](#TurmaDisciplinaProfessorCompletoDTO.java)
      - [Atributos:](#Atributos:)
  - [Repositório TurmaDisciplinaProfessorRepository.java](#Repositório-TurmaDisciplinaProfessorRepository.java)
    - [Métodos](#Métodos)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [Conclusão](#Conclusão)
- [Package Usuario](#Package-Usuario)
  - [Visão Geral](#Visão-Geral)
  - [Classe Usuario.java](#Classe-Usuario.java)
    - [Descrição](#Descrição)
    - [Anotações](#Anotações)
    - [Atributos Principais](#Atributos-Principais)
    - [Validações](#Validações)
    - [Regras de Negócio](#Regras-de-Negócio)
  - [Conclusão](#Conclusão)
- [Package de Configuração](#Package-de-Configuração)
  - [Pi3MediotecApplication.java](#Pi3MediotecApplication.java)
    - [Descrição](#Descrição)
    - [Anotações](#Anotações)
    - [Método Principal](#Método-Principal)
  - [SwaggerConfig.java](#SwaggerConfig.java)
    - [Descrição](#Descrição)
    - [Anotações](#Anotações)
    - [Métodos](#Métodos)
    - [Principais Configurações](#Principais-Configurações)
  - [WebConfig.java](#WebConfig.java)
    - [Descrição](#Descrição)
    - [Anotações](#Anotações)
    - [Métodos](#Métodos)
  - [Conclusão](#Conclusão)
- [Capítulo 3 - Configurações da Aplicação](#Capítulo-3---Configurações-da-Aplicação)
  - [Configurações do `application.properties`](#Configurações-do-`application.properties`)
    - [1. Configuração Básica da Aplicação](#1.-Configuração-Básica-da-Aplicação)
    - [2. Configurações do Banco de Dados](#2.-Configurações-do-Banco-de-Dados)
    - [3. Configurações do Hibernate](#3.-Configurações-do-Hibernate)
    - [4. Configurações Regionais e de Fuso Horário](#4.-Configurações-Regionais-e-de-Fuso-Horário)
    - [5. Configuração do Swagger UI](#5.-Configuração-do-Swagger-UI)
  - [Conclusão](#Conclusão)
- [Configurações do pom.xml](#Configurações-do-pom.xml)
  - [Estrutura do pom.xml](#Estrutura-do-pom.xml)
    - [Informações do Projeto](#Informações-do-Projeto)
    - [Propriedades](#Propriedades)
    - [Dependências](#Dependências)
      - [SpringDoc OpenAPI](#SpringDoc-OpenAPI)
      - [Spring Boot Validation](#Spring-Boot-Validation)
      - [Spring Boot Data JPA](#Spring-Boot-Data-JPA)
      - [Spring Boot Web](#Spring-Boot-Web)
      - [Spring Boot DevTools](#Spring-Boot-DevTools)
      - [MySQL Connector](#MySQL-Connector)
      - [PostgreSQL Driver](#PostgreSQL-Driver)
      - [Lombok](#Lombok)
      - [Spring Boot Starter Test](#Spring-Boot-Starter-Test)
    - [Plugins](#Plugins)
      - [Spring Boot Maven Plugin](#Spring-Boot-Maven-Plugin)
  - [Conclusão](#Conclusão)
- [Capítulo 4 - Documentação do Banco de Dados](#Capítulo-4---Documentação-do-Banco-de-Dados)
  - [1. Introdução](#1.-Introdução)
  - [2. Tabelas](#2.-Tabelas)
    - [2.1 Tabela aluno](#2.1-Tabela-aluno)
      - [Relacionamentos:](#Relacionamentos:)
    - [2.2 Tabela professor](#2.2-Tabela-professor)
      - [Relacionamentos:](#Relacionamentos:)
    - [2.3 Tabela disciplina](#2.3-Tabela-disciplina)
      - [Relacionamentos:](#Relacionamentos:)
    - [2.4 Tabela turma](#2.4-Tabela-turma)
      - [Relacionamentos:](#Relacionamentos:)
    - [2.5 Tabela responsavel](#2.5-Tabela-responsavel)
    - [2.6 Tabela telefone](#2.6-Tabela-telefone)
    - [2.7 Tabela coordenacao](#2.7-Tabela-coordenacao)
    - [2.8 Tabela turma_disciplina_professor](#2.8-Tabela-turma_disciplina_professor)
    - [2.9 Tabela conceito](#2.9-Tabela-conceito)
    - [2.10 Tabela presenca](#2.10-Tabela-presenca)
    - [2.11 Tabela horario](#2.11-Tabela-horario)
    - [2.12 Tabela comunicado](#2.12-Tabela-comunicado)
    - [2.13 Tabela comunicado_receptor_alunos e comunicado_receptor_turmas](#2.13-Tabela-comunicado_receptor_alunos-e-comunicado_receptor_turmas)
      - [Comunicado_Receptor_Alunos](#Comunicado_Receptor_Alunos)
      - [Comunicado_Receptor_Turmas](#Comunicado_Receptor_Turmas)
  - [3. Relacionamentos Principais](#3.-Relacionamentos-Principais)
- [Capítulo 5 - Endpoints](#Capítulo-5---Endpoints)
  - [Introdução](#Introdução)
  - [1. Aluno](#1.-Aluno)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [2. Professor](#2.-Professor)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [3. Coordenação](#3.-Coordenação)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [4. Disciplina](#4.-Disciplina)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [5. Turma](#5.-Turma)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [6. Responsável](#6.-Responsável)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [7. Conceito](#7.-Conceito)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [8. Comunicado](#8.-Comunicado)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
  - [9. Presenca](#9.-Presenca)
    - [Exemplo de cadastro (POST - Mínimo):](#Exemplo-de-cadastro-(POST---Mínimo):)
    - [Exemplo de cadastro (POST - Máximo):](#Exemplo-de-cadastro-(POST---Máximo):)
    - [Exemplo de consulta (GET - Completo):](#Exemplo-de-consulta-(GET---Completo):)
- [Capítulo 6 - Em Desenvolvimento (futuras melhorias)](#Capítulo-6---Em-Desenvolvimento-(futuras-melhorias))
  - [1. Tratamento de Erros Mais Robustos](#1.-Tratamento-de-Erros-Mais-Robustos)
  - [2. Encapsulamento da Regra de Negócio](#2.-Encapsulamento-da-Regra-de-Negócio)
  - [3. Configuração Mais Forte das Bilateralidades](#3.-Configuração-Mais-Forte-das-Bilateralidades)
  - [4. Implementação de Spring Security](#4.-Implementação-de-Spring-Security)
  - [5. Auditoria e Logs de Atividade](#5.-Auditoria-e-Logs-de-Atividade)
  - [6. Melhorias na Performance e Escalabilidade](#6.-Melhorias-na-Performance-e-Escalabilidade)
    - [7. Testes Automatizados](#7.-Testes-Automatizados)
    - [8. Integração de APIs](#8.-Integração-de-APIs)
- [Capítulo 7 - Instalação, Uso e Dependências](#Capítulo-7-Instalação-Uso-e-Dependências)
  - [1. Instruções de Instalação](#1-Instruções-de-Instalação)
    - [Instalar Eclipse](#Instalar-Eclipse)
    - [Instalar Dependências Adicionais](#Instalar-Dependências-Adicionais)
  - [2. Instruções de Uso](#2-Instruções-de-Uso)
    - [Abrir o Eclipse](#Abrir-o-Eclipse)
    - [Executar o Projeto](#Executar-o-Projeto)
    - [Configuração do application.properties](#Configuração-do-application.properties)
    - [Exemplo de Configuração do application.properties](#Exemplo-de-Configuração-do-application.properties)
    - [Configurar as Variáveis de Ambiente](#Configurar-as-Variáveis-de-Ambiente)
  - [3. Dependências do Projeto](#3-Dependências-do-Projeto)
    - [Java 11 ou Superior](#Java-11-ou-Superior)
    - [Spring Boot](#Spring-Boot)
    - [MySQL ou PostgreSQL](#MySQL-ou-PostgreSQL)
    - [Maven](#Maven)



---


# Capítulo 1 - Estrutura Geral dos Pacotes no Sistema SGE

O Sistema de Gerenciamento Escolar (SGE) foi desenvolvido utilizando o framework Spring Boot e segue uma estrutura de pacotes bem organizada, onde cada um representa uma funcionalidade específica do sistema. Essa organização promove um código limpo, que facilita o desenvolvimento, manutenção e escalabilidade, além de garantir a separação clara das responsabilidades.

Os pacotes do projeto são estruturados como módulos, cada um responsável por uma entidade e suas operações correspondentes. Essa abordagem modular permite a separação das camadas de entidade, controle, serviço, repositório e DTOs (Data Transfer Objects), garantindo um código bem estruturado, de fácil compreensão e manutenção.

## Estrutura dos Pacotes

Abaixo está a estrutura hierárquica dos pacotes e arquivos de classes, que reflete a organização do sistema. Cada entidade tem suas próprias camadas de lógica de negócio, persistência e controle:

```
projeto.integrador3.senac.mediotec.pi3_mediotec
│
├── aluno
│   ├── Aluno.java
│   ├── AlunoController.java
│   ├── AlunoDTO.java
│   ├── AlunoRepository.java
│   ├── AlunoService.java
│   └── ...
├── comunicado
│   ├── Comunicado.java
│   ├── ComunicadoController.java
│   ├── ComunicadoDTO.java
│   └── ...
├── conceito
│   ├── Conceito.java
│   ├── ConceitoController.java
│   ├── ConceitoDTO.java
│   ├── ConceitoService.java
│   └── ...
├── coordenacao
│   ├── Coordenacao.java
│   ├── CoordenacaoController.java
│   ├── CoordenacaoService.java
│   └── ...
├── coordenador
│   ├── Coordenador.java
│   ├── CoordenadorController.java
│   └── ...
├── disciplina
│   ├── Disciplina.java
│   ├── DisciplinaController.java
│   └── ...
├── endereco
│   ├── Endereco.java
│   ├── EnderecoController.java
│   └── ...
├── horario
│   ├── Horario.java
│   ├── HorarioController.java
│   └── ...
├── presenca
│   ├── Presenca.java
│   ├── PresencaController.java
│   └── ...
├── professor
│   ├── Professor.java
│   ├── ProfessorController.java
│   └── ...
├── responsavel
│   ├── Responsavel.java
│   ├── ResponsavelController.java
│   └── ...
├── telefone
│   ├── Telefone.java
│   ├── TelefoneController.java
│   └── ...
├── turma
│   ├── Turma.java
│   ├── TurmaController.java
│   └── ...
├── turmaDisciplinaProfessor
│   ├── TurmaDisciplinaProfessor.java
│   ├── TurmaDisciplinaProfessorController.java
│   └── ...
└── usuario
    └── Usuario.java
```

## Explicação da Estrutura

A arquitetura do sistema foi desenvolvida seguindo o princípio da **separação de responsabilidades** (*Separation of Concerns*), no qual cada componente ou camada do sistema desempenha um papel específico. Esse princípio foi aplicado de maneira rigorosa para garantir que as operações de cada entidade (como Aluno, Professor, Disciplina, etc.) sejam gerenciadas por suas respectivas classes. Isso resulta em um código mais organizado, modular e fácil de manter.

- **Entidades**: Representam os dados que serão persistidos no banco (exemplo: `Aluno.java`, `Professor.java`).
- **Controladores**: Exponibilizam endpoints REST para a comunicação com o front-end e outros serviços (exemplo: `AlunoController.java`, `DisciplinaController.java`).
- **Serviços**: Contêm a lógica de negócio, processando e validando dados antes de salvar ou consultar as informações no repositório (exemplo: `AlunoService.java`, `ConceitoService.java`).
- **Repositórios**: Lidam com a persistência dos dados, realizando operações de CRUD (Create, Read, Update, Delete) diretamente no banco de dados (exemplo: `AlunoRepository.java`, `ProfessorRepository.java`).
- **DTOs**: Objetos para transferência de dados entre as camadas de serviço e controle, garantindo que apenas as informações necessárias sejam expostas e transmitidas (exemplo: `AlunoDTO.java`, `ComunicadoDTO.java`).  

## Modularidade

A modularidade é um ponto central nesta arquitetura. Cada módulo (ou pacote) está isolado das demais funcionalidades, o que permite a modificação ou adição de novas entidades sem impactar outras partes do sistema. Isso torna o código mais sustentável a longo prazo e facilita a incorporação de novos recursos.

Por exemplo, se for necessário adicionar um novo módulo, como uma entidade de "Avaliação", isso pode ser feito de forma simples, seguindo o padrão já estabelecido:

```
├── avaliacao
│   ├── Avaliacao.java
│   ├── AvaliacaoController.java
│   ├── AvaliacaoDTO.java
│   ├── AvaliacaoRepository.java
│   └── AvaliacaoService.java
```

Esse modelo oferece não apenas flexibilidade, mas também segurança, pois cada parte do sistema trabalha de maneira independente, com responsabilidades bem definidas. Isso minimiza erros e facilita o teste de cada módulo isoladamente, garantindo que novas funcionalidades ou correções sejam implementadas de maneira eficiente e segura.


---


# Entidades no Sistema SGE

## O que são Entidades?

As Entidades no SGE (Sistema de Gerenciamento Escolar) representam as tabelas no banco de dados. Cada entidade é uma classe que reflete os dados armazenados em tabelas e utiliza as anotações do JPA (Java Persistence API) para mapear seus atributos e relacionamentos entre outras entidades. As entidades no SGE são usadas para manipular dados essenciais como alunos, professores, turmas e presenças.

## Estrutura e Funcionalidades no Java, Spring e SGE

No contexto de Java e Spring, as entidades são classes Java simples (POJOs) que representam registros de banco de dados. O JPA fornece o mapeamento objeto-relacional, permitindo que o desenvolvedor interaja com os dados usando objetos Java, sem necessidade de escrever SQL manualmente. Além disso, o Lombok facilita a redução do código "boilerplate" nas entidades.

## O que é JPA?

JPA (Java Persistence API) é uma especificação Java que simplifica o processo de mapeamento objeto-relacional (ORM). Ele permite que os desenvolvedores interajam com bancos de dados relacionais usando objetos Java, facilitando a persistência de dados sem a necessidade de escrever queries SQL diretamente.

### Funcionalidades da JPA

- **Mapeamento Objeto-Relacional (ORM)**: A JPA mapeia automaticamente classes e seus atributos para tabelas e colunas no banco de dados.
- **Gerenciamento de Transações**: A JPA gerencia transações para garantir que operações de leitura e escrita sejam realizadas de forma consistente.
- **Consultas JPQL**: A JPA oferece uma linguagem de consulta específica (JPQL) que permite realizar buscas e manipulações diretamente nos objetos Java.
- **Caching**: A JPA implementa cache para melhorar a performance ao buscar entidades previamente consultadas.

## Uso do Lombok nas Entidades

O Lombok é uma biblioteca que ajuda a reduzir a quantidade de código repetitivo nas entidades, como getters, setters, construtores, entre outros. Usamos o Lombok para gerar automaticamente esses métodos com o uso de anotações simples.

### Principais Anotações do Lombok

- **@Getter** e **@Setter**: Geram automaticamente os métodos get() e set() para todos os atributos.
- **@NoArgsConstructor**: Gera um construtor sem argumentos.
- **@AllArgsConstructor**: Gera um construtor com todos os atributos da classe.
- **@Builder**: Facilita a criação de objetos utilizando o padrão Builder.
- **@EqualsAndHashCode**: Gera os métodos equals() e hashCode(), essenciais para comparar objetos.
- **@ToString**: Gera automaticamente o método toString().

## Anotações Comuns da JPA

As entidades no SGE usam várias anotações para garantir o mapeamento correto entre as classes Java e o banco de dados:

- **@Entity**: Define a classe como uma entidade JPA que será gerenciada pelo banco de dados.
- **@Table(name = "nome_da_tabela")**: Especifica o nome da tabela no banco de dados.
- **@Id**: Define o campo como chave primária da tabela.
- **@GeneratedValue(strategy = GenerationType.IDENTITY)**: Configura a estratégia de geração automática do identificador primário, onde o banco de dados é responsável por gerar o valor.
- **@Column**: Define características específicas para colunas no banco, como unicidade e obrigatoriedade.
- **@ManyToOne, @OneToMany, @ManyToMany, @OneToOne**: Definem os relacionamentos entre as entidades.

## Exemplo de Entidade com JPA e Lombok: `Aluno.java`

A seguir está o exemplo de uma entidade **Aluno**, que representa a tabela aluno no banco de dados. Ela usa tanto anotações do JPA para mapeamento objeto-relacional quanto anotações do Lombok para reduzir o código repetitivo.

```java
@Entity
@Table(name = "aluno")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Aluno {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "matricula_aluno")
    private Long id;

    @NotNull
    @Column(unique = true, nullable = false)
    private String cpf;

    @NotNull
    @Column(nullable = false)
    private String nome;

    private boolean status;

    // Relacionamento um-para-muitos com Endereco
    @OneToMany(mappedBy = "aluno", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Endereco> enderecos = new HashSet<>();

    // Relacionamento muitos-para-muitos com Turma
    @ManyToMany(mappedBy = "alunos", cascade = CascadeType.ALL)
    private Set<Turma> turmas = new HashSet<>();
}
```

## Relacionamentos Entre Entidades

No SGE, as entidades possuem relacionamentos entre si que refletem as conexões entre as tabelas do banco de dados. A JPA gerencia automaticamente esses relacionamentos, garantindo a persistência correta dos dados.

### Exemplo de Relacionamento

- Na entidade **Aluno**, podemos observar dois tipos de relacionamentos:
    - **Um-para-muitos**: Um aluno pode ter vários endereços, mas um endereço pertence a apenas um aluno.
    - **Muitos-para-muitos**: Um aluno pode estar matriculado em várias turmas, e uma turma pode conter vários alunos.

```java
// Um aluno pode ter vários endereços
@OneToMany(mappedBy = "aluno", cascade = CascadeType.ALL, orphanRemoval = true)
private Set<Endereco> enderecos = new HashSet<>();

// Um aluno pode estar em várias turmas, e uma turma pode conter vários alunos
@ManyToMany(mappedBy = "alunos", cascade = CascadeType.ALL)
private Set<Turma> turmas = new HashSet<>();
```

Esses relacionamentos são geridos automaticamente pelo JPA. Ao adicionar ou remover um endereço ou uma turma, o Spring garante que as informações sejam sincronizadas corretamente no banco de dados.

## Anotações para Validação

Para garantir a integridade dos dados, utilizamos o **Bean Validation** e anotações de validação do JPA. Elas ajudam a aplicar restrições em atributos específicos das entidades, como por exemplo:

- **@NotNull**: Garante que o campo não será nulo.
- **@Size(min = 5, max = 100)**: Limita o tamanho do campo, útil para strings como nomes.
- **@Column(nullable = false, unique = true)**: Impede que o campo seja nulo ou contenha valores duplicados.

### Exemplo de validação em atributos da entidade `Aluno`:

```java
@NotNull
@Column(unique = true, nullable = false)
private String cpf;

@NotNull
@Column(nullable = false)
private String nome;
```

## Métodos Auxiliares

É comum nas entidades criar métodos auxiliares para facilitar o gerenciamento de relacionamentos. Por exemplo, ao adicionar um endereço ou uma turma, é importante garantir que a relação bidirecional entre as entidades seja mantida. Aqui estão exemplos de métodos auxiliares para a entidade **Aluno**:

```java
// Método auxiliar para adicionar um endereço
public void addEndereco(Endereco endereco) {
    endereco.setAluno(this);  // Define o aluno no endereço
    this.enderecos.add(endereco);  // Adiciona o endereço ao conjunto de endereços do aluno
}

// Método auxiliar para adicionar uma turma
public void addTurma(Turma turma) {
    this.turmas.add(turma);  // Adiciona a turma ao conjunto de turmas do aluno
    turma.getAlunos().add(this);  // Adiciona o aluno ao conjunto de alunos da turma
}
```

Esses métodos garantem que a relação entre **Aluno** e suas entidades relacionadas (como **Endereco** e **Turma**) seja sempre consistente e que ambas as direções do relacionamento estejam atualizadas corretamente.

## Resumo: Importância das Entidades, JPA e Lombok no SGE

As entidades no SGE são a espinha dorsal do sistema, representando os dados no banco de dados. O uso da JPA facilita o mapeamento objeto-relacional, permitindo que o sistema manipule dados de forma eficiente e segura. O Lombok simplifica o código, reduzindo a quantidade de getters, setters e outros métodos repetitivos.

### Benefícios

- **JPA**: Fornece um mapeamento simples e direto entre classes Java e tabelas de banco de dados, além de gerenciar relacionamentos e transações de forma automatizada.
- **Lombok**: Elimina código repetitivo e facilita a manutenção das entidades.
- **Validação**: Garante que os dados estejam sempre no formato correto e evita problemas de inconsistência no banco.

Esse conjunto de práticas e tecnologias garante que o sistema seja robusto, fácil de manter e escalável.


---


# Repositórios no Sistema SGE

## O que são Repositórios?

Os Repositórios no SGE (Sistema de Gerenciamento Escolar) são interfaces que gerenciam o acesso e a persistência de dados no banco de dados. Eles atuam como a camada de acesso a dados, fornecendo uma abstração sobre a lógica de armazenamento, permitindo que as operações CRUD (Create, Read, Update, Delete) sejam realizadas de forma simples e eficiente. O Spring Data JPA é usado para facilitar a implementação desses repositórios, eliminando a necessidade de escrever SQL manual.

## Estrutura e Funcionalidade no Java, Spring e SGE

No Spring, os repositórios são interfaces que herdam de interfaces prontas fornecidas pelo Spring Data JPA, como a `JpaRepository`, o que simplifica a criação de operações básicas de banco de dados. O Spring Data JPA cuida da implementação, permitindo que os desenvolvedores concentrem-se na lógica de negócios.

## Principais Anotações e Funcionalidades

Os repositórios no SGE seguem uma estrutura padronizada, aproveitando a funcionalidade do Spring Data JPA. Algumas anotações e funcionalidades importantes incluem:

- **@Repository**: Marca a interface como um componente de repositório, tornando-a disponível para injeção de dependências pelo Spring.
- **JpaRepository<T, ID>**: Interface fornecida pelo Spring Data JPA que já contém métodos CRUD prontos. Ela é parametrizada com o tipo da entidade (T) e o tipo do identificador (ID).
- **Consultas personalizadas**: Além dos métodos padrão do Spring Data, como `findAll()`, `save()`, `deleteById()`, é possível criar consultas personalizadas apenas declarando o método no repositório com base em convenções de nomes (ex.: `findByNome()`).

## Exemplo de Interface de Repositório

No exemplo abaixo, o repositório `AlunoRepository` é responsável por gerenciar as operações de persistência da entidade Aluno. Ele herda de `JpaRepository`, o que fornece os métodos CRUD padrão, e também define uma consulta personalizada para buscar alunos pelo CPF.

```java
@Repository
public interface AlunoRepository extends JpaRepository<Aluno, Long> {

    // Método para buscar aluno pelo CPF
    Optional<Aluno> findByCpf(String cpf);
    
    // Verifica se existe um aluno com determinado CPF
    boolean existsByCpf(String cpf);
}
```

## Métodos Comuns Herdados de JpaRepository

A interface `JpaRepository` fornece uma série de métodos prontos para realizar operações CRUD e consultas no banco de dados. Alguns métodos comuns incluem:

- `findAll()`: Retorna todos os registros da entidade no banco de dados.
- `findById(ID id)`: Retorna um registro pela chave primária.
- `save(T entity)`: Salva ou atualiza um registro da entidade.
- `deleteById(ID id)`: Remove um registro pela chave primária.

Esses métodos permitem realizar as operações básicas de forma rápida e eficiente, sem a necessidade de implementar lógica de acesso a dados.

## Consultas Personalizadas

O Spring Data JPA permite criar consultas personalizadas apenas declarando os métodos na interface do repositório. O Spring constrói automaticamente a implementação dessas consultas com base nos nomes dos métodos.

### Exemplo de Consulta Personalizada

No repositório `AlunoRepository`, temos um método `findByCpf`, que permite buscar um aluno pelo CPF. O Spring Data JPA entende que deve construir uma consulta SQL com base no nome do método.

```java
Optional<Aluno> findByCpf(String cpf);
```

Além disso, é possível criar consultas mais complexas utilizando a anotação `@Query`. Esta abordagem é útil quando as convenções de nomes não são suficientes para expressar a consulta desejada.

### Exemplo de Consulta com @Query

```java
@Query("SELECT a FROM Aluno a WHERE a.nome LIKE %:nome%")
List<Aluno> findByNomeContains(@Param("nome") String nome);
```

Esse exemplo cria uma consulta personalizada que busca alunos cujo nome contenha o valor passado no parâmetro.

## Injeção de Dependências

No Spring, os repositórios são injetados nos Serviços ou Controladores para que possam ser utilizados para acessar os dados. Isso é feito por meio da anotação `@Autowired`, que permite ao Spring resolver as dependências automaticamente.

### Exemplo de Injeção de Dependências

A injeção de dependências em um serviço é feita da seguinte maneira:

```java
@Service
public class AlunoService {

    @Autowired
    private AlunoRepository alunoRepository;

    public AlunoDTO getAlunoByCpf(String cpf) {
        Aluno aluno = alunoRepository.findByCpf(cpf)
            .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));
        return convertToDTO(aluno);
    }
}
```

Neste exemplo, o `AlunoRepository` é injetado no `AlunoService`, permitindo que o serviço faça consultas no banco de dados.

## Resumo: Importância dos Repositórios no SGE

Os repositórios são a camada de acesso a dados no SGE, permitindo que as operações CRUD sejam realizadas de maneira eficiente e desacoplada da lógica de negócios. O uso de Spring Data JPA simplifica a implementação dos repositórios, permitindo que os desenvolvedores se concentrem nas regras de negócio, enquanto o Spring cuida da persistência de dados.

### Benefícios

- **Abstração do Banco de Dados**: A interface `JpaRepository` fornece uma abstração de alto nível, eliminando a necessidade de código SQL manual.
- **Consultas Personalizadas**: O Spring Data JPA permite criar consultas customizadas de forma simples, sem a necessidade de escrever queries SQL.
- **Injeção de Dependências**: A integração com o Spring Framework facilita a injeção de repositórios em serviços e controladores, promovendo um código mais limpo e modular.

Os repositórios são essenciais para garantir que o acesso a dados seja feito de maneira eficiente, segura e organizada dentro do SGE.

---

# Serviços no Sistema SGE

## O que são Serviços?

Os Serviços (Services) no SGE (Sistema de Gerenciamento Escolar) implementam a lógica de negócios do sistema. Eles são a camada intermediária entre os Repositórios (que interagem diretamente com o banco de dados) e os Controladores (que processam as requisições HTTP). Nos serviços, são aplicadas validações, regras de negócio e manipulação de dados antes de interagir com o banco de dados.

No Spring Framework, as classes de serviço são anotadas com `@Service`, o que permite ao Spring gerenciar a criação e injeção de dependências, além de facilitar o fluxo de transações e operações.

## Estrutura e Funcionalidades no Java, Spring e SGE

Os serviços no SGE seguem um padrão de injeção de dependências, onde os Repositórios e outros componentes são injetados nos serviços para permitir o acesso aos dados e a execução de regras de negócios. Cada serviço trata das regras de negócios específicas de uma ou mais entidades, garantindo que as operações sejam feitas de maneira consistente e eficiente.

## Principais Anotações e Funcionalidades

- **@Service**: Define a classe como um serviço gerenciado pelo Spring, permitindo que o Spring crie instâncias e injete dependências automaticamente.
- **@Autowired**: Realiza a injeção de dependências de outros componentes, como repositórios ou outros serviços.
- **@Transactional**: Em serviços que manipulam múltiplas operações de banco de dados, essa anotação garante que todas as operações sejam executadas de forma atômica, ou seja, ou todas são concluídas com sucesso ou nenhuma é executada.

## Métodos Comuns em Serviços

Os serviços no SGE geralmente seguem um padrão de métodos comuns que manipulam as operações CRUD (Create, Read, Update, Delete), realizam validações e aplicam regras de negócio. Além disso, eles também incluem métodos específicos que tratam da conversão de dados entre entidades e DTOs (Data Transfer Objects).

### 1. Métodos CRUD (Create, Read, Update, Delete)

Os métodos CRUD são fundamentais para a gestão de dados de qualquer sistema. Eles permitem criar, buscar, atualizar e deletar entidades no banco de dados. Aqui, explico como funciona cada um desses métodos no contexto de um serviço.

#### Criação de uma Entidade (Create)

O método `criarAluno()` é responsável por criar uma nova entidade no banco de dados. Ele recebe um DTO contendo os dados do aluno, converte-o em uma entidade e, em seguida, o repositório persiste essa entidade no banco de dados.

##### Exemplo:

```java
public AlunoDTO criarAluno(AlunoDTO alunoDTO) {
    // Conversão do DTO para entidade
    Aluno aluno = convertToEntity(alunoDTO);
    
    // Salvando a entidade no banco de dados
    aluno = alunoRepository.save(aluno);
    
    // Convertendo a entidade de volta para DTO para retorno
    return convertToDTO(aluno);
}
```

#### Busca de Dados (Read)

O método `buscarAlunoPorId()` faz uma consulta no banco de dados para encontrar um aluno com base no seu ID. Se o aluno não for encontrado, é lançada uma exceção apropriada.

##### Exemplo:

```java
public AlunoDTO buscarAlunoPorId(Long id) {
    Aluno aluno = alunoRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));
    return convertToDTO(aluno);
}
```

#### Atualização de uma Entidade (Update)

O método `atualizarAluno()` é usado para modificar os dados de um aluno existente. Ele primeiro busca o aluno pelo ID e, em seguida, atualiza seus campos com base nos dados fornecidos no DTO.

##### Exemplo:

```java
public AlunoDTO atualizarAluno(Long id, AlunoDTO alunoDTO) {
    Aluno aluno = alunoRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));
    
    // Atualizando os dados da entidade
    aluno.setNome(alunoDTO.getNome());
    aluno.setCpf(alunoDTO.getCpf());

    // Salvando as alterações
    alunoRepository.save(aluno);
    
    return convertToDTO(aluno);
}
```

#### Deleção de uma Entidade (Delete)

O método `deletarAluno()` remove uma entidade do banco de dados com base no seu ID. Ele primeiro verifica se o aluno existe antes de tentar removê-lo.

##### Exemplo:

```java
public void deletarAluno(Long id) {
    Aluno aluno = alunoRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));
    
    // Removendo o aluno
    alunoRepository.delete(aluno);
}
```

### 2. Validações e Regras de Negócio

Os serviços não apenas executam operações de banco de dados, mas também garantem que as regras de negócio sejam aplicadas corretamente. Antes de realizar qualquer operação, verificações e validações são executadas.

#### Exemplo de Regra de Negócio:

No exemplo abaixo, ao matricular um aluno em uma turma, o serviço verifica se a turma já atingiu sua capacidade máxima antes de realizar a matrícula.

```java
public AlunoDTO matricularAlunoEmTurma(Long alunoId, Long turmaId) {
    Aluno aluno = alunoRepository.findById(alunoId)
        .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));

    Turma turma = turmaRepository.findById(turmaId)
        .orElseThrow(() -> new EntityNotFoundException("Turma não encontrada"));

    // Validação da capacidade da turma
    if (turma.getAlunos().size() >= turma.getCapacidadeMaxima()) {
        throw new IllegalStateException("A turma já está cheia.");
    }

    // Adiciona o aluno à turma
    aluno.getTurmas().add(turma);
    alunoRepository.save(aluno);

    return convertToDTO(aluno);
}
```

### 3. Métodos Específicos

Os serviços também podem conter métodos que encapsulam lógicas de negócios mais complexas. Por exemplo, calcular a média de notas de um aluno ou gerar relatórios.

#### Exemplo:

```java
public double calcularMediaNotas(Long alunoId) {
    Aluno aluno = alunoRepository.findById(alunoId)
        .orElseThrow(() -> new EntityNotFoundException("Aluno não encontrado"));

    return aluno.getNotas().stream()
        .mapToDouble(Nota::getValor)
        .average()
        .orElse(0.0);
}
```

### 4. Métodos de Conversão (DTOs)

Os serviços também são responsáveis por converter as entidades em DTOs e vice-versa. Isso garante que a camada de apresentação manipule apenas os dados necessários.

#### Exemplo:

```java
private AlunoDTO convertToDTO(Aluno aluno) {
    AlunoDTO alunoDTO = new AlunoDTO();
    alunoDTO.setId(aluno.getId());
    alunoDTO.setNome(aluno.getNome());
    alunoDTO.setCpf(aluno.getCpf());
    return alunoDTO;
}

private Aluno convertToEntity(AlunoDTO alunoDTO) {
    Aluno aluno = new Aluno();
    aluno.setNome(alunoDTO.getNome());
    aluno.setCpf(alunoDTO.getCpf());
    return aluno;
}
```

## Resumo: Importância dos Serviços no SGE

Os Serviços no SGE desempenham um papel central na aplicação da lógica de negócios. Eles garantem que os dados sejam manipulados de forma correta antes de serem salvos no banco de dados, aplicando validações e regras específicas do sistema.

### Benefícios:

- **Aplicação das Regras de Negócio**: Os serviços garantem que todas as regras de negócio sejam aplicadas corretamente.
- **Abstração do Banco de Dados**: Eles fornecem uma camada de abstração entre o banco de dados e os controladores.
- **Conversão de DTOs**: Garantem que apenas os dados necessários sejam transferidos entre as camadas do sistema.
- **Centralização da Lógica de Negócios**: Mantêm a lógica centralizada, o que facilita a manutenção e a escalabilidade do sistema.

Os serviços são essenciais para garantir a integridade dos dados e o funcionamento correto do sistema, proporcionando uma arquitetura limpa e modular.


---


# DTOs no Sistema SGE

## O que são DTOs?

Os DTOs (Data Transfer Objects) são objetos simples que transportam dados entre as camadas do sistema, como entre o Controller e o Service ou entre o Service e o Repository. Eles são usados para garantir que apenas os dados necessários sejam expostos ou recebidos, evitando o tráfego desnecessário de informações e aumentando a segurança da aplicação.

No SGE (Sistema de Gerenciamento Escolar), os DTOs são usados para encapsular dados de entidades como Aluno, Turma ou Curso, limitando os atributos visíveis e manipulados pelas diferentes camadas do sistema. Ao utilizar DTOs, também garantimos uma maior separação entre as camadas de negócios e de apresentação, tornando o sistema mais modular e seguro.

## Estrutura e Funcionalidade no Java, Spring e SGE

No contexto do Spring Framework, os DTOs são simples classes POJOs (Plain Old Java Objects), sem nenhuma lógica de negócios, que contêm apenas atributos e, geralmente, getters e setters. Além disso, eles podem ser anotados com validações para garantir que os dados recebidos pelas requisições estejam no formato correto antes de serem processados pelos serviços.

### Quando Utilizar DTOs

- **Transferência de dados**: DTOs são usados para transferir dados entre as camadas sem expor toda a entidade.
- **Segurança**: Ao não expor diretamente as entidades, evitamos o risco de manipulações indevidas de dados sensíveis.
- **Validação**: DTOs permitem validar os dados que chegam pela API antes que eles sejam manipulados pelo sistema.

## Criação de DTOs no Sistema

### Estrutura Simples de um DTO

Um DTO é, essencialmente, uma classe que contém atributos com seus respectivos getters e setters. Não há lógica de negócios dentro do DTO; ele serve apenas como um contêiner de dados. Além disso, podemos usar anotações para validações, como `@NotNull` e `@Size`, para garantir que os dados estejam corretos antes de serem processados.

### Exemplo de DTO para a Entidade Aluno

```java
public class AlunoDTO {

    private Long id;

    @NotNull(message = "O nome é obrigatório")
    @Size(min = 3, max = 100, message = "O nome deve ter entre 3 e 100 caracteres")
    private String nome;

    @NotNull(message = "O CPF é obrigatório")
    private String cpf;

    // Getters e Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getCpf() {
        return cpf;
    }

    public void setCpf(String cpf) {
        this.cpf = cpf;
    }
}
```

### Como o DTO Funciona:

- **Encapsulamento dos Dados**: O `AlunoDTO` contém apenas os campos essenciais para a transferência de dados entre o sistema e a interface. Aqui, por exemplo, apenas o ID, nome e CPF do aluno são expostos.
- **Validações**: O uso das anotações `@NotNull` e `@Size` garante que os dados estejam no formato correto e não vazios. Caso essas validações falhem, uma mensagem de erro personalizada será retornada.

## Conversão Entre DTOs e Entidades

Em muitos casos, é necessário converter os DTOs recebidos em Entidades para que sejam persistidos no banco de dados. Da mesma forma, é necessário converter Entidades em DTOs antes de retornar os dados ao cliente. Essa conversão geralmente é feita na camada de Serviços.

### Exemplo de Conversão Entre DTO e Entidade

No serviço, criamos métodos auxiliares para realizar a conversão entre DTO e Entidade. Isso garante que a lógica de conversão esteja centralizada e fácil de manter.

### Conversão de DTO para Entidade

Quando um `AlunoDTO` é recebido, ele precisa ser convertido para a entidade Aluno para ser salvo no banco.

```java
public Aluno convertToEntity(AlunoDTO alunoDTO) {
    Aluno aluno = new Aluno();
    aluno.setId(alunoDTO.getId());
    aluno.setNome(alunoDTO.getNome());
    aluno.setCpf(alunoDTO.getCpf());
    return aluno;
}
```

### Conversão de Entidade para DTO

Da mesma forma, ao buscar um aluno no banco de dados, a entidade `Aluno` precisa ser convertida em `AlunoDTO` antes de ser retornada ao cliente.

```java
public AlunoDTO convertToDTO(Aluno aluno) {
    AlunoDTO alunoDTO = new AlunoDTO();
    alunoDTO.setId(aluno.getId());
    alunoDTO.setNome(aluno.getNome());
    alunoDTO.setCpf(aluno.getCpf());
    return alunoDTO;
}
```

## Vantagens do Uso de DTOs

- **Segurança dos Dados**: Ao usar DTOs, garantimos que apenas os dados necessários sejam expostos e manipulados. Dados sensíveis da entidade podem ser ocultados.
- **Validação Simplificada**: DTOs permitem que as validações sejam aplicadas na camada de entrada, antes mesmo que os serviços sejam acionados. Isso previne dados inválidos no banco de dados.
- **Separação de Responsabilidades**: Com a separação entre DTOs e Entidades, o sistema ganha modularidade, permitindo mudanças nas entidades sem impactar diretamente a camada de apresentação.
- **Desempenho**: Como DTOs contêm apenas os dados essenciais, eles são leves e rápidos para serem transferidos, o que melhora a performance de requisições e respostas na API.

## Resumo: Importância dos DTOs no SGE

Os DTOs são essenciais no SGE para garantir que os dados sejam manipulados e transferidos de forma segura e eficiente entre as camadas do sistema. Eles evitam o tráfego de dados desnecessários e expõem apenas o que é necessário para cada operação.

### Benefícios:

- **Segurança**: Protegem a integridade dos dados, evitando que informações sensíveis sejam expostas.
- **Validações**: Garantem que apenas dados válidos sejam processados e salvos no sistema.
- **Modularidade**: A separação entre DTOs e Entidades facilita a manutenção e evolução do sistema sem causar quebras na lógica de negócios.

No contexto do SGE, os DTOs desempenham um papel importante ao oferecer uma estrutura clara e eficiente para manipular dados entre as diferentes camadas da aplicação.

---


# Controladores (Controllers) no Sistema SGE

## O que são Controladores?

Os Controladores (Controllers) no SGE (Sistema de Gerenciamento Escolar) são responsáveis por gerenciar as requisições HTTP que chegam à aplicação. Eles servem como ponto de entrada para as APIs, processando as requisições recebidas e delegando a execução das operações para os Serviços (Services). Os controladores também cuidam das respostas enviadas de volta para o cliente, garantindo que os dados retornem de forma adequada e no formato correto.

No Spring, os controladores são classes anotadas com `@RestController` e `@RequestMapping`, o que define as rotas HTTP e permite que o Spring gerencie as requisições HTTP como GET, POST, PUT e DELETE.

## Estrutura e Funcionalidade no Java, Spring e SGE

Os Controladores seguem o padrão MVC (Model-View-Controller). Eles atuam como a interface entre o cliente e os serviços do sistema. Cada endpoint (ou rota) no controlador é associado a uma funcionalidade específica do sistema, como criar um aluno, buscar uma turma ou atualizar um curso.

## Principais Anotações e Funcionalidades

- **@RestController**: Define a classe como um controlador REST, que gerencia as requisições HTTP e retorna dados no formato JSON ou XML.
- **@RequestMapping**: Define o caminho base de todas as rotas do controlador. Por exemplo, `@RequestMapping("/alunos")` define que todas as rotas relacionadas ao controlador de alunos começarão com `/alunos`.
- **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**: Definem os métodos HTTP que a rota aceita. Cada um corresponde a uma operação CRUD:
    - **@GetMapping**: Usado para consultas (GET).
    - **@PostMapping**: Usado para criação de novos recursos (POST).
    - **@PutMapping**: Usado para atualização de recursos (PUT).
    - **@DeleteMapping**: Usado para remoção de recursos (DELETE).
- **@PathVariable** e **@RequestBody**: Usadas para capturar parâmetros da URL e do corpo da requisição, respectivamente.

## Exemplos de Métodos Comuns em Controladores

Os controladores no SGE geralmente contêm rotas para CRUD (Criar, Ler, Atualizar, Deletar) de entidades, como Aluno, Turma, Curso, entre outros. Aqui estão exemplos de controladores comumente utilizados no SGE, explicando a lógica por trás de cada método.

### 1. Buscar Todos os Alunos (GET)

O método `listarTodosAlunos()` é responsável por retornar uma lista de todos os alunos cadastrados. Ele utiliza o `AlunoService` para buscar os dados e retorna uma lista de `AlunoDTOs`.

```java
@RestController
@RequestMapping("/alunos")
public class AlunoController {

    @Autowired
    private AlunoService alunoService;

    @GetMapping
    public ResponseEntity<List<AlunoDTO>> listarTodosAlunos() {
        List<AlunoDTO> alunos = alunoService.listarTodosAlunos();
        return ResponseEntity.ok(alunos);  // Retorna HTTP 200 OK com a lista de alunos
    }
}
```

### 2. Buscar Aluno por ID (GET)

O método `buscarAlunoPorId()` é usado para buscar um aluno específico pelo seu ID. Ele recebe o ID na URL e delega a busca para o serviço.

```java
@GetMapping("/{id}")
public ResponseEntity<AlunoDTO> buscarAlunoPorId(@PathVariable Long id) {
    try {
        AlunoDTO aluno = alunoService.buscarAlunoPorId(id);
        return ResponseEntity.ok(aluno);  // HTTP 200 OK se o aluno for encontrado
    } catch (EntityNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);  // HTTP 404 Not Found
    }
}
```

### 3. Criar Novo Aluno (POST)

O método `criarAluno()` é responsável por receber os dados de um novo aluno e delegar a criação ao serviço correspondente.

```java
@PostMapping
public ResponseEntity<AlunoDTO> criarAluno(@RequestBody AlunoDTO alunoDTO) {
    try {
        AlunoDTO novoAluno = alunoService.criarAluno(alunoDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(novoAluno);  // HTTP 201 Created
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);  // HTTP 400 Bad Request
    }
}
```

### 4. Atualizar Aluno (PUT)

O método `atualizarAluno()` recebe o ID de um aluno e os dados atualizados no corpo da requisição. Ele delega ao serviço a responsabilidade de buscar o aluno, atualizar os dados e persistir as alterações.

```java
@PutMapping("/{id}")
public ResponseEntity<AlunoDTO> atualizarAluno(@PathVariable Long id, @RequestBody AlunoDTO alunoDTO) {
    try {
        AlunoDTO alunoAtualizado = alunoService.atualizarAluno(id, alunoDTO);
        return ResponseEntity.ok(alunoAtualizado);  // HTTP 200 OK com o aluno atualizado
    } catch (EntityNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);  // HTTP 404 Not Found
    }
}
```

### 5. Deletar Aluno (DELETE)

O método `deletarAluno()` remove um aluno do banco de dados pelo seu ID.

```java
@DeleteMapping("/{id}")
public ResponseEntity<Void> deletarAluno(@PathVariable Long id) {
    try {
        alunoService.deletarAluno(id);
        return ResponseEntity.noContent().build();  // HTTP 204 No Content
    } catch (EntityNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();  // HTTP 404 Not Found
    }
}
```

## Tratamento de Erros nos Controladores

Os controladores também são responsáveis por tratar erros e exceções. Eles utilizam blocos `try-catch` para capturar exceções como `EntityNotFoundException` (quando um recurso não é encontrado) e retornar códigos HTTP adequados, como 404 Not Found ou 400 Bad Request.

```java
@GetMapping("/{id}")
public ResponseEntity<AlunoDTO> buscarAlunoPorId(@PathVariable Long id) {
    try {
        AlunoDTO aluno = alunoService.buscarAlunoPorId(id);
        return ResponseEntity.ok(aluno);  // HTTP 200 OK se o aluno for encontrado
    } catch (EntityNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);  // HTTP 404 Not Found
    }
}
```

## Resumo: Importância dos Controladores no SGE

Os Controladores no SGE são a porta de entrada para as requisições HTTP e servem como intermediários entre o cliente e os serviços do sistema. Eles lidam com a lógica de roteamento, delegando as operações para os serviços e garantindo que as respostas sejam retornadas no formato correto.

### Benefícios:

- **Facilidade de Rotas**: Os controladores facilitam o mapeamento das rotas e gerenciam as requisições de forma eficiente.
- **Intermediário entre o Cliente e os Serviços**: Eles garantem que as requisições cheguem aos serviços corretamente e que as respostas sejam enviadas com status apropriados.
- **Tratamento de Exceções**: Capturam e tratam erros e exceções para garantir uma experiência robusta e consistente para o usuário.

Os controladores são fundamentais para conectar os clientes aos serviços e fornecer uma interface clara e organizada para interagir com a aplicação.


--- 

# Capítulo 2 - Explicação dos Pacotes

Este capítulo é dedicado à explicação detalhada de cada pacote presente no **SGE (Sistema de Gerenciamento Escolar)**. Cada pacote foi projetado para representar uma funcionalidade específica do sistema, com uma estrutura clara e organizada que abrange as camadas de entidade, repositório, serviço, controlador e DTOs (Data Transfer Objects). 

Cada pacote será explicado de maneira individual, com foco nas suas particularidades. Componentes que são comuns a todos os pacotes, como a utilização de anotações e métodos CRUD (Create, Read, Update, Delete), serão brevemente mencionados. O foco estará nos detalhes específicos que cada pacote implementa, as regras de negócio aplicadas e como as diferentes classes se conectam para garantir o funcionamento correto de cada funcionalidade.

## Estrutura Geral

Para cada pacote, seguiremos a ordem:

1. **Entidade (Entity)**: Representa os dados que serão persistidos no banco de dados. A entidade é mapeada para uma tabela e define os atributos e relacionamentos essenciais.
2. **Repositório (Repository)**: Interface que gerencia a comunicação com o banco de dados, permitindo a realização de operações de CRUD e consultas personalizadas.
3. **Serviço (Service)**: Contém a lógica de negócios aplicada sobre os dados, validando informações e processando operações antes da interação com o banco de dados.
4. **DTO (Data Transfer Object)**: Objetos usados para transferir dados entre as camadas de serviço e controle, garantindo que apenas as informações necessárias sejam expostas.
5. **Controlador (Controller)**: Define os endpoints REST que expõem a API para comunicação com o cliente. O controlador gerencia as requisições HTTP, delegando as operações ao serviço correspondente.

Cada parte será explicada com exemplos de código e detalhes sobre o funcionamento interno, priorizando a clareza para que a arquitetura do sistema seja fácil de entender e manter.

---


# Package aluno

### Aluno.java (Entidade)
 
A classe Aluno representa a entidade aluno, contendo atributos e relacionamentos específicos com outras entidades no sistema. Ela é a base de todas as interações relacionadas aos alunos no sistema, herda de Usuario, e é mapeada para a tabela `aluno` no banco de dados.

**Anotações**:
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "aluno")`: Nome da tabela no banco de dados.
- `@Id`: Define o campo id como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Utiliza a estratégia de geração automática de IDs.
- `@OneToMany`, `@ManyToMany`, `@ManyToOne`: Relacionamentos com outras entidades.
- `@JsonIgnore`: Ignora certos campos na serialização JSON para evitar loops e dados desnecessários.

**Relacionamentos**:
- **Endereços** (`@OneToMany`): Um aluno pode ter vários endereços.
- **Telefones** (`@OneToMany`): Um aluno pode ter vários telefones.
- **Turmas** (`@ManyToMany`): Um aluno pode estar em várias turmas.
- **Responsáveis** (`@OneToMany`): Um aluno pode ter vários responsáveis.
- **Coordenação** (`@ManyToOne`): Relacionamento de coordenação com o aluno.

**Regras de Negócio**:
- O CPF é obrigatório e único.
- O status do aluno é `true` (ativo) por padrão ao ser cadastrado.
- O aluno deve ter ao menos um responsável no momento do cadastro.

**Métodos Auxiliares**:
- `addEndereco(Endereco endereco)`: Relaciona um endereço ao aluno.
- `addTelefone(Telefone telefone)`: Relaciona um telefone ao aluno.
- `addTurma(Turma turma)`: Relaciona uma turma ao aluno.
- `addResponsavel(Responsavel responsavel)`: Relaciona um responsável ao aluno.


---


### AlunoRepository.java (Repositório)


Interface que gerencia a persistência dos dados do aluno. Estende `JpaRepository`, o que permite realizar operações CRUD e consultas adicionais no banco de dados sem a necessidade de implementar manualmente as queries.

**Métodos**:
- `findAll()`: Retorna todos os alunos.
- `findById(Long id)`: Busca um aluno pelo ID.
- `existsByCpf(String cpf)`: Verifica se um aluno com determinado CPF já existe no banco.

**Regras de Negócio**:
- **CPF único**: Garante que não seja possível cadastrar dois alunos com o mesmo CPF.

---

### AlunoService.java (Serviço)

A classe AlunoService contém a lógica de negócios relacionada ao aluno, sendo responsável pela interação com o `AlunoRepository`, aplicação das regras de negócio e validações, além de fornecer os dados ao controlador.

**Métodos**:
- `getAllAlunos()`: Retorna todos os alunos cadastrados.
- `getAlunoById(Long idAluno)`: Retorna um aluno específico pelo ID. Se o aluno não for encontrado, lança uma `EntityNotFoundException`.
- `saveAluno(AlunoResumidoDTO2 alunoResumidoDTO)`: Persiste um novo aluno no banco.

**Regras de Negócio**:
- O CPF deve ser único.
- O aluno deve ser criado com status ativo (`true`).
- Pelo menos um responsável é necessário.

- `updateAluno(Long idAluno, AlunoResumidoDTO2 alunoResumidoDTO)`: Atualiza um aluno existente, mantendo a unicidade do CPF e as regras relacionadas a responsáveis.
- `deleteAluno(Long idAluno)`: Remove um aluno pelo ID. Verifica dependências como presença ou matrícula em turmas antes de permitir a exclusão.

---

### AlunoDTO.java (DTO)
 
DTO utilizado para transferir os dados completos do aluno entre a aplicação e o cliente via API. Contém todos os atributos do aluno, incluindo relacionamentos com endereços, telefones, turmas e responsáveis.

---

### AlunoResumidoDTO.java (DTO)

Esse DTO contém apenas as informações básicas do aluno, utilizado principalmente para operações de criação e atualização, evitando o tráfego de dados desnecessários.

---

### AlunoResumidoDTO2.java (DTO)
 
Um DTO similar ao AlunoResumidoDTO, utilizado em diferentes contextos de criação ou atualização de aluno, com pequenas variações nos atributos.

---

### AlunoReduzidoDTO.java (DTO)

Esse DTO é utilizado para representar um aluno de maneira mais simples, com apenas os atributos essenciais como nome, CPF e status. Usado em listas ou exibições onde dados detalhados não são necessários.

---

### AlunoController.java (Controlador)

O `AlunoController` expõe os endpoints REST para as operações de CRUD relacionadas ao aluno. Ele interage com o `AlunoService` para realizar operações e aplicar as regras de negócio.

**Endpoints**:

#### GET
- `/alunos`: Retorna a lista de todos os alunos.
- `/alunos/{id}`: Retorna os detalhes de um aluno específico.
- `/alunos/{idAluno}/conceitos`: Retorna os conceitos de um aluno.

#### POST
- `/alunos`: Cria um novo aluno.

**Validações**:
- CPF deve ser único.
- O aluno deve ser cadastrado como ativo.

#### PUT
- `/alunos/{id}`: Atualiza os dados de um aluno existente.

#### DELETE
- `/alunos/{id}`: Remove um aluno pelo ID, verificando se não existem dependências bloqueantes.

---

## Conclusão

O package `aluno` é uma parte fundamental do sistema, gerenciando o ciclo de vida dos alunos, desde o cadastro até a exclusão. As camadas de entidade, repositório, serviço e controlador estão bem definidas, garantindo que a lógica de negócio, persistência e exposição de APIs estejam separadas e organizadas de forma modular. O uso de DTOs permite trafegar apenas os dados necessários, mantendo a segurança e performance do sistema.


--- 


# Package comunicado

O package comunicado é responsável pelo gerenciamento das entidades e operações relacionadas aos comunicados no sistema. Este pacote lida com o envio de comunicados, persistência de dados, regras de negócio específicas para professores e coordenadores, além da exposição de APIs REST. Abaixo está a explicação técnica de cada arquivo presente no package, seguindo a ordem Entidade > Repositório > Serviço > DTOs > Controlador.

### Comunicado.java (Entidade)
  
A classe Comunicado representa a entidade comunicado, que é enviada para alunos ou turmas por coordenadores ou professores. Cada comunicado contém informações como conteúdo, remetente e data de envio.

**Anotações**:
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "comunicado")`: Define o nome da tabela como comunicado.
- `@Id`: Define o campo id como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o valor do ID com a estratégia IDENTITY.
- `@ManyToOne`: Indica o relacionamento entre o comunicado e o remetente (professor ou coordenador).

**Relacionamentos**:
- **Remetente (Professor ou Coordenador)** (`@ManyToOne`): Define que um comunicado pode ser enviado por um professor ou coordenador.
- **Turma** (`@ManyToOne`): Um comunicado pode ser destinado a uma turma específica.

**Regras de Negócio**:
- O conteúdo do comunicado é obrigatório.
- O remetente deve ser um professor ou coordenador ativo no sistema.
- A data de envio é automaticamente definida no momento da criação do comunicado.

---

### ComunicadoRepository.java (Repositório)
  
Interface que gerencia a persistência de comunicados. Herda de `JpaRepository`, permitindo operações CRUD e consultas personalizadas relacionadas a comunicados.

**Métodos**:
- `findAll()`: Retorna todos os comunicados.
- `findByRemetenteProfessor_Cpf(String cpf)`: Busca comunicados enviados por um professor específico, utilizando o CPF como parâmetro.
- `findByTurma_Id(Long id)`: Retorna todos os comunicados destinados a uma turma específica.

**Regras de Negócio**:
- Comunicados podem ser filtrados por remetente (professor ou coordenador) ou turma específica.

---

### ComunicadoService.java (Serviço)
  
O ComunicadoService é responsável por implementar a lógica de negócios referente aos comunicados. Ele interage com o `ComunicadoRepository` para manipular os dados e aplica as validações necessárias antes de persistir ou buscar dados.

**Métodos**:
- `getAllComunicados()`: Retorna todos os comunicados cadastrados no sistema.
- `getComunicadosPorProfessor(String cpfProfessor)`: Busca comunicados enviados por um professor, utilizando o CPF do professor como filtro.

**Regras de Negócio**:
- Verifica se o professor está ativo no sistema.

- `getComunicadosPorTurma(Long idTurma)`: Retorna todos os comunicados de uma turma específica.
- `criarComunicadoPorCoordenador(Long idCoordenador, ComunicadoDTO comunicadoDTO)`: Permite que um coordenador crie e envie um comunicado para uma turma.

**Regras de Negócio**:
- O coordenador deve estar vinculado a uma coordenação ativa.
- O conteúdo do comunicado é obrigatório.

- `criarComunicadoPorProfessor(Long idProfessor, ComunicadoDTO comunicadoDTO)`: Permite que um professor envie comunicados.

**Regras de Negócio**:
- O professor deve estar ativo e associado à turma.
- O conteúdo do comunicado é obrigatório.
- O remetente deve ser válido e ativo no sistema.
- O comunicado pode ser destinado a uma turma específica ou a um grupo de alunos.

---

### ComunicadoDTO.java (DTO)
  
O ComunicadoDTO é utilizado para transferir os dados relacionados ao comunicado entre o cliente e o sistema. Ele contém os dados essenciais do comunicado, como conteúdo, data de envio e destinatário (turma ou aluno).

**Atributos**:
- **Conteúdo**: Texto do comunicado.
- **Data de Envio**: Data em que o comunicado foi criado.
- **Remetente**: Dados do professor ou coordenador que enviou o comunicado.
- **Destinatário**: Dados da turma ou aluno que recebeu o comunicado.

**Validações**:
- O campo conteúdo é obrigatório e deve ter um tamanho mínimo definido.

---

### ComunicadoController.java (Controlador)

A classe ComunicadoController expõe os endpoints REST para operações relacionadas ao envio, listagem, atualização e exclusão de comunicados no sistema. O controlador interage com o `ComunicadoService` para aplicar as regras de negócio e persistir os dados de comunicados no banco.

**Anotações**:
- `@RestController`: Define a classe como um controlador REST, que processa e responde as requisições HTTP no formato JSON.
- `@RequestMapping("/comunicados")`: Define a rota base para todas as operações relacionadas aos comunicados.
- `@Tag(name = "Comunicados", description = "Operações relacionadas aos comunicados")`: Agrupa as operações relacionadas aos comunicados para fins de documentação via Swagger.

### Rotas (Endpoints):

#### POST
- `/coordenacao/{coordenacaoId}/coordenador/{coordenadorId}`: Cria um comunicado emitido por um coordenador para alunos ou turmas específicos.

**Validações**:
- O coordenador deve estar vinculado a uma coordenação ativa.
- O conteúdo do comunicado é obrigatório.

- `/coordenacao/{coordenacaoId}/coordenador/{coordenadorId}/todos`: Cria um comunicado enviado para todos os alunos e todas as turmas.

**Validações**:
- O coordenador deve estar ativo.
- O conteúdo do comunicado é obrigatório.

- `/professor/{professorId}`: Cria um comunicado emitido por um professor.

**Validações**:
- O professor deve estar ativo no sistema.

#### PUT
- `/coordenacao/{coordenacaoId}/coordenador/{coordenadorId}/{comunicadoId}`: Atualiza um comunicado enviado por um coordenador.

**Validações**:
- O coordenador deve estar ativo.
- O comunicado deve existir no banco de dados.

- `/professor/{professorId}/{comunicadoId}`: Atualiza um comunicado enviado por um professor.

**Validações**:
- O professor deve estar ativo.
- O comunicado deve existir no banco de dados.

#### DELETE
- `/coordenacao/{coordenacaoId}/coordenador/{coordenadorId}/{comunicadoId}`: Remove um comunicado emitido por um coordenador.

**Validações**:
- O coordenador deve estar ativo.
- O comunicado deve existir no banco de dados.

- `/professor/{professorId}/{comunicadoId}`: Remove um comunicado emitido por um professor.

**Validações**:
- O professor deve estar ativo.
- O comunicado deve existir no banco de dados.

#### GET
- `/comunicados`: Lista todos os comunicados do sistema.
- `/alunos`: Lista todos os comunicados enviados para alunos.
- `/aluno/{alunoId}`: Busca todos os comunicados enviados para um aluno específico.
- `/turmas`: Lista todos os comunicados enviados para turmas.
- `/turma/{turmaId}`: Busca todos os comunicados enviados para uma turma específica.
- `/coordenador/{coordenadorId}`: Lista todos os comunicados enviados por um coordenador específico.
- `/professor/{professorId}`: Lista todos os comunicados enviados por um professor específico.

### Tratamento de Erros:

- **400 Bad Request**: Utilizado para erros de validação ou falhas ao processar a requisição.
- **404 Not Found**: Utilizado quando o comunicado, coordenador, ou professor não é encontrado no banco de dados.
- **409 Conflict**: Pode ser utilizado em casos de conflitos, como a tentativa de criação de um comunicado com dados inválidos ou duplicados.

---

## Conclusão

O package comunicado é essencial para a comunicação entre coordenadores, professores e alunos no sistema. Ele oferece uma estrutura organizada para a criação e envio de comunicados, garantindo que as informações sejam filtradas por turma ou remetente. As camadas de entidade, repositório, serviço e controlador estão bem definidas e permitem a correta manipulação dos dados de forma modular e eficiente. O uso de DTOs garante que apenas os dados necessários sejam trafegados nas requisições, mantendo a performance e a segurança do sistema.


---


# Package conceito

O package conceito é responsável por gerenciar os conceitos e notas dos alunos no sistema. Ele lida com o armazenamento, cálculo e consulta de conceitos por disciplina, além de permitir a visualização das médias dos alunos. O pacote expõe APIs REST que possibilitam a interação com esses dados e é composto pelas camadas de entidade, repositório, serviço e controlador.

### Conceito.java (Entidade)

A classe Conceito representa a entidade conceito, que armazena as notas dos alunos associadas às disciplinas e turmas. Ela reflete a avaliação acadêmica dos alunos em uma determinada disciplina.

**Anotações**:
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "conceito")`: Define o nome da tabela como conceito.
- `@Id`: Define o campo id como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o ID do conceito.
- `@ManyToOne`: Relacionamento entre conceitos, alunos e disciplinas.

**Relacionamentos**:
- **Aluno** (`@ManyToOne`): Cada conceito está relacionado a um aluno específico.
- **Disciplina** (`@ManyToOne`): O conceito está vinculado a uma disciplina, representando a nota do aluno nessa disciplina.

**Atributos Principais**:
- **Nota**: Armazena a nota obtida pelo aluno em uma disciplina.
- **Média**: Pode ser calculada com base em várias notas, como avaliações parciais.
- **Conceito**: Um conceito descritivo (por exemplo, Excelente, Bom, Regular) gerado a partir da média.

**Regras de Negócio**:
- A nota deve ser um valor numérico válido.
- Cada conceito deve estar vinculado a um aluno e a uma disciplina.
- O conceito descritivo é gerado automaticamente com base na média.

---

### ConceitoRepository.java (Repositório)
  
O ConceitoRepository é responsável por realizar as operações de persistência e consulta dos conceitos no banco de dados. Ele estende `JpaRepository`, o que permite realizar operações CRUD e consultas personalizadas para buscar conceitos de alunos e disciplinas.

**Métodos**:
- `findAll()`: Retorna todos os conceitos cadastrados.
- `findByAluno_IdAndDisciplina_Id(Long alunoId, Long disciplinaId)`: Busca o conceito de um aluno em uma disciplina específica.
- `findByAluno_Id(Long alunoId)`: Retorna todos os conceitos de um aluno.

**Regras de Negócio**:
- Cada conceito deve ser único por aluno e disciplina.
- Consultas podem ser realizadas filtrando por aluno, disciplina ou turma.

---

### ConceitoService.java (Serviço)

A classe ConceitoService gerencia toda a lógica de negócios relacionada ao conceito dos alunos, lidando com operações de CRUD, cálculos de notas e a atribuição de status de aprovação ou reprovação. Também implementa a lógica para o uso de notas de recuperação (NOA1 e NOA2) e a recuperação final (NOA Final).

## Anotações:

- **@Service**: Define a classe como um serviço do Spring.
- **@Transactional**: Garante que as operações de banco de dados sejam atômicas.

## Métodos CRUD:

- **buscarConceitoPorId(Long id)**:
  - Busca um conceito específico por ID.
  - **Validações**: Lança exceção se o conceito não for encontrado.

- **salvarConceito(ConceitoResumidoDTO conceitoResumidoDTO)**:
  - Salva um novo conceito.
  - **Regras de Negócio**:
    - Vincula o conceito a um aluno e uma turma/disciplina.
    - Calcula os conceitos e a média com base nas notas fornecidas.
    - Realiza a persistência no banco de dados após aplicar as regras.

- **atualizarConceito(Long id, ConceitoResumidoDTO conceitoResumidoDTO)**:
  - Atualiza um conceito existente.
  - **Validações**: Verifica se o conceito existe. Caso contrário, lança uma exceção.
  - **Regras de Negócio**:
    - Atualiza as notas e recalcula os conceitos e a média.
    - Aplica as regras de NOA1 e NOA2 quando aplicável.

- **deletarConceito(Long id)**:
  - Remove um conceito do banco de dados.
  - **Validações**: Verifica se o conceito existe antes de remover, caso contrário, lança uma exceção.

## Cálculos de Notas e Regras de Negócio

### 1. Cálculo das Notas de Recuperação: NOA1 e NOA2

As notas de recuperação **NOA1** e **NOA2** oferecem a oportunidade de melhorar as menores notas das unidades.

- **NOA1**: Substitui a menor nota entre as Unidades 1 e 2.
- **NOA2**: Substitui a menor nota entre as Unidades 3 e 4.

#### Regras de Substituição:

- **NOA1**:
  - Se **NOA1** for maior que a Nota da Unidade 1, e essa for menor que a da Unidade 2, substitui a Nota da Unidade 1.
  - Se **NOA1** for maior que a Nota da Unidade 2, substitui essa nota.

- **NOA2**:
  - Se **NOA2** for maior que a Nota da Unidade 3, e essa for menor que a da Unidade 4, substitui a Nota da Unidade 3.
  - Se **NOA2** for maior que a Nota da Unidade 4, substitui essa nota.

#### Exemplo de Substituição:

- Nota Unidade 1: 5.0  
- Nota Unidade 2: 6.0  
- **NOA1**: 7.0  
  Neste caso, a Nota da Unidade 1 será substituída por 7.0.

### 2. Cálculo da Média Final

A média final é calculada com base nas quatro unidades. A fórmula padrão é:

```java
media = (notaUnidade1 + notaUnidade2 + notaUnidade3 + notaUnidade4) / 4;
```

Após o cálculo da média, o sistema verifica a necessidade de aplicar o NOA Final, explicado a seguir.

### 3. NOA Final: Recuperação Final

O NOA Final é aplicado quando a média fica entre 5.0 e 6.9. Se a média das unidades for inferior a 7.0, mas maior ou igual a 5.0, o aluno pode realizar a recuperação final.

#### Regras para Uso do NOA Final:

Se aplicável, o NOA Final recalcula a média do aluno usando a fórmula:

```java
mediaFinal = (media + noaFinal) / 2;
```

#### Exemplo de Aplicação:

- Média das unidades: 6.5  
- **NOA Final**: 7.0  

A média final será:

```java
mediaFinal = (6.5 + 7.0) / 2;
mediaFinal = 6.75;
```

### 4. Critérios de Aprovação e Reprovação

O sistema segue os seguintes critérios:

- **Aprovação direta**: Média das unidades ≥ 7.0.
- **Reprovação direta**: Média < 5.0.
- **Aptidão para NOA Final**: Média entre 5.0 e 6.9.

#### Aprovação com NOA Final:

Se, após o recálculo da média com o NOA Final, o aluno atingir 7.0 ou mais, ele é considerado aprovado.

```java
if (mediaFinal >= 7.0) {
    conceito.setAprovado(true);
} else {
    conceito.setAprovado(false);
}
```

### 5. Implementação dos Cálculos no Sistema

Os métodos da classe ConceitoService aplicam automaticamente essas regras de negócio e realizam o recalculo das médias sempre que necessário.

- **calcularConceitos(Conceito conceito)**:

  Este método recalcula os conceitos das unidades com base nas notas fornecidas e aplica as regras de NOA1 e NOA2.

```java
if (conceito.getNoa1() != null) {
    if (conceito.getNotaUnidade1() != null && conceito.getNotaUnidade2() != null) {
        if (conceito.getNoa1() > conceito.getNotaUnidade1() && conceito.getNotaUnidade1() < conceito.getNotaUnidade2()) {
            conceito.setNotaUnidade1(conceito.getNoa1());
        } else if (conceito.getNoa1() > conceito.getNotaUnidade2()) {
            conceito.setNotaUnidade2(conceito.getNoa1());
        }
    }
}
```

- **calcularMediaEStatus(Conceito conceito)**:

  Calcula a média final e determina o status de aprovação do aluno com base nas regras descritas. Se a média for inferior a 7.0 e maior ou igual a 5.0, o NOA Final pode ser aplicado para recalcular a média.

```java
Float media = (conceito.getNotaUnidade1() + conceito.getNotaUnidade2() + ... ) / 4;

if (media < 7 && media >= 5 && conceito.getNoaFinal() != null) {
    media = (media + conceito.getNoaFinal()) / 2;
}

conceito.setMediaFinal(media);

if (media >= 7) {
    conceito.setAprovado(true);
} else {
    conceito.setAprovado(false);
}
```

### Conceitos Descritivos:

- **Excelente (E)**: Nota ≥ 9.5
- **Ótimo (O)**: Nota ≥ 8.5 e < 9.5
- **Bom (B)**: Nota ≥ 7.0 e < 8.5
- **ANS (Ainda Não Suficiente)**: Nota ≥ 5.0 e < 7.0
- **Insuficiente (I)**: Nota < 5.0

---

### ConceitoController.java (Controlador)

O ConceitoController expõe os endpoints REST para gerenciar os conceitos dos alunos. Ele lida com operações de busca, criação, atualização e exclusão de conceitos. O controlador garante que as regras de negócio sejam aplicadas corretamente e utiliza o ConceitoService para realizar essas operações.

**Anotações**:
- `@RestController`: Define a classe como um controlador REST.
- `@RequestMapping("/conceitos")`: Define a rota base para todas as operações relacionadas aos conceitos.
- `@Tag(name = "Conceitos", description = "Operações relacionadas aos conceitos dos alunos")`: Agrupa as operações relacionadas aos conceitos na documentação do Swagger.

### Rotas (Endpoints):

#### GET
- `/conceitos/{id}`: Busca um conceito específico pelo ID.

**Validações**:
- Verifica se o conceito existe. Caso contrário, retorna 404 Not Found.

#### POST
- `/conceitos`: Cria um novo conceito no sistema.

**Validações**:
- O conceito deve estar vinculado a um aluno e a uma disciplina.
- As notas fornecidas devem ser válidas e seguir as regras de negócio.
- As notas de recuperação, se fornecidas, podem ser usadas para substituir as menores notas.

#### PUT
- `/conceitos/{id}`: Atualiza um conceito existente.

**Validações**:
- O conceito deve existir no banco de dados.
- As notas fornecidas devem ser válidas e seguir as regras de recalculação de média e status de aprovação.

#### DELETE
- `/conceitos/{id}`: Deleta um conceito do sistema.

**Validações**:
- Verifica se o conceito existe. Caso contrário, retorna 404 Not Found.

### Tratamento de Erros:

- **400 Bad Request**: Utilizado para erros de validação de dados ou quando a criação/atualização de um conceito falha.
- **404 Not Found**: Utilizado quando o conceito ou o recurso solicitado não é encontrado no banco de dados.
- **500 Internal Server Error**: Utilizado em casos de erros inesperados no servidor.

---

## Conclusão

O package conceito lida com a lógica de avaliações e atribuição de conceitos para alunos. Através do controlador, os usuários podem criar, buscar, atualizar e remover conceitos, seguindo as regras de negócios relacionadas ao cálculo de notas e conceitos descritivos. O serviço aplica regras específicas, como a utilização de notas de recuperação (NOA) e o cálculo de médias, assegurando que os conceitos dos alunos sejam precisos e reflitam corretamente o desempenho acadêmico.


---

# Package coordenacao

O package coordenacao é responsável pelo gerenciamento das coordenações no sistema, que envolvem associações com coordenadores, turmas, professores, endereços e telefones. A coordenação é uma entidade fundamental no contexto educacional, pois organiza a estrutura das turmas e o corpo docente. Este package segue a arquitetura de camadas, organizando suas responsabilidades em entidade, repositório, serviço, DTOs e controlador REST.

### Coordenacao.java (Entidade)

A classe Coordenacao é a entidade que representa a coordenação de uma instituição educacional. Ela define os atributos e relacionamentos que uma coordenação possui, como nome, descrição e associações com turmas, professores, endereços e coordenadores.

**Anotações**:
- `@Entity`: Define que a classe será uma entidade JPA.
- `@Table(name = "coordenacao")`: Especifica o nome da tabela como "coordenacao".
- `@Id`: Define o campo id como a chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o valor do ID.

**Relacionamentos**:
- **Endereços** (`@OneToMany`): Uma coordenação pode ter múltiplos endereços.
- **Telefones** (`@OneToMany`): Uma coordenação pode ter múltiplos telefones.
- **Coordenadores** (`@OneToMany`): Uma coordenação pode ter vários coordenadores.
- **Turmas** (`@OneToMany`): Uma coordenação gerencia várias turmas.
- **Professores** (`@OneToMany`): Uma coordenação pode estar associada a múltiplos professores.

**Atributos Principais**:
- **Nome**: O nome da coordenação (obrigatório e com restrição de tamanho).
- **Descrição**: Uma descrição opcional sobre a coordenação.

---

### Métodos Auxiliares

Os métodos auxiliares na classe Coordenacao são responsáveis por facilitar o gerenciamento das associações entre a coordenação e outras entidades relacionadas, como endereços, telefones, coordenadores, turmas e professores. Estes métodos asseguram que os relacionamentos sejam bidirecionais e consistentes.

#### addEndereco(Endereco endereco)

**Função**:  
Associa um endereço à coordenação, garantindo que ambos os lados do relacionamento sejam atualizados.

```java
public void addEndereco(Endereco endereco) {
    endereco.setCoordenacao(this); 
    this.enderecos.add(endereco);
}
```

#### addTelefone(Telefone telefone)

**Função**:  
Associa um telefone à coordenação.

```java
public void addTelefone(Telefone telefone) {
    telefone.setCoordenacao(this); 
    this.telefones.add(telefone);
}
```

#### addCoordenador(Coordenador coordenador)

**Função**:  
Adiciona um coordenador à coordenação.

```java
public void addCoordenador(Coordenador coordenador) {
    coordenador.setCoordenacao(this); 
    this.coordenadores.add(coordenador);
}
```

#### addTurma(Turma turma)

**Função**:  
Associa uma turma à coordenação.

```java
public void addTurma(Turma turma) {
    turma.setCoordenacao(this); 
    this.turmas.add(turma);
}
```

#### addProfessor(Professor professor)

**Função**:  
Adiciona um professor à coordenação.

```java
public void addProfessor(Professor professor) {
    professor.setCoordenacao(this); 
    this.professores.add(professor);
}
```

---

### CoordenacaoRepository.java (Repositório)
  
A interface CoordenacaoRepository define a camada de persistência da entidade Coordenacao, permitindo operações de CRUD e consultas ao banco de dados.

**Métodos**:
- `findAll()`: Retorna uma lista de todas as coordenações cadastradas.
- `findById(Long id)`: Busca uma coordenação pelo seu ID.

---

### CoordenacaoService.java (Serviço)
  
A classe CoordenacaoService contém a lógica de negócios da coordenação. Ela gerencia as operações de criação, leitura, atualização e exclusão, além de aplicar as regras associadas ao gerenciamento de coordenadores, turmas, professores, endereços e telefones.

**Anotações**:
- `@Service`: Define que a classe é um serviço gerenciado pelo Spring.
- `@Transactional`: Garante que as operações do serviço sejam executadas de forma transacional.

**Métodos**:
- `getAllCoordenacoes()`: Retorna uma lista de todas as coordenações no sistema, convertidas para DTO.
- `getCoordenacaoById(Long id)`: Busca uma coordenação específica pelo ID.
- `saveCoordenacao(CoordenacaoCadastroDTO coordenacaoDTO)`: Persiste uma nova coordenação no banco de dados.
- `updateCoordenacao(Long id, CoordenacaoCadastroDTO coordenacaoDTO)`: Atualiza uma coordenação existente.
- `deleteCoordenacao(Long id)`: Remove uma coordenação do banco de dados.

---

### CoordenacaoDTO.java e CoordenacaoCadastroDTO.java (DTOs)
  
Os Data Transfer Objects (DTOs) são utilizados para transferir os dados de entrada e saída entre a API e o cliente. A coordenação possui dois tipos principais de DTOs: o CoordenacaoDTO e o CoordenacaoCadastroDTO.

**Atributos**:
- **CoordenacaoDTO**: Representa os dados completos da coordenação, incluindo suas associações com endereços, telefones, turmas, professores e coordenadores.
- **CoordenacaoCadastroDTO**: Usado para criar ou atualizar uma coordenação.

---

### CoordenacaoController.java (Controlador)

A classe CoordenacaoController expõe os endpoints REST para operações relacionadas à coordenação. Ela permite a criação, leitura, atualização e exclusão de coordenações, bem como o gerenciamento de suas associações com outras entidades.

**Anotações**:
- `@RestController`: Define que a classe é um controlador REST.
- `@RequestMapping("/coordenacoes")`: Define a rota base para todas as operações relacionadas à coordenação.
- `@Tag(name = "Coordenações", description = "Operações relacionadas às coordenações")`: Agrupa as operações para fins de documentação no Swagger.

### Rotas (Endpoints):

#### GET
- `/coordenacoes`: Retorna uma lista de todas as coordenações cadastradas.
- `/coordenacoes/{id}`: Busca uma coordenação específica pelo ID.

#### POST
- `/coordenacoes`: Cria uma nova coordenação no sistema.

#### PUT
- `/coordenacoes/{id}`: Atualiza uma coordenação existente.

#### DELETE
- `/coordenacoes/{id}`: Exclui uma coordenação pelo ID.

### Tratamento de Erros:
- **404 Not Found**: Retornado quando uma coordenação ou entidade associada não é encontrada.
- **400 Bad Request**: Utilizado para erros de validação nos dados fornecidos.
- **500 Internal Server Error**: Retornado em casos de erros inesperados no servidor.

---

## Conclusão

O package coordenacao é responsável por todo o gerenciamento das coordenações no sistema. Através de suas entidades, serviços e controladores, ele permite criar, consultar, atualizar e excluir coordenações, assegurando que as associações com entidades relacionadas, como coordenadores, professores e turmas, sejam corretamente mantidas. Com uma arquitetura bem estruturada, o package facilita a administração das coordenações no ambiente educacional.


---

# Package coordenador

O package coordenador é responsável por gerenciar as operações relacionadas aos coordenadores no sistema. Um coordenador é uma entidade que supervisiona turmas, professores e outros aspectos organizacionais dentro de uma instituição educacional. Este pacote trata da persistência, lógica de negócios e da exposição de APIs REST para manipulação dos coordenadores. Ele segue uma arquitetura de camadas com as entidades, repositórios, serviços, DTOs e controladores.

### Coordenador.java (Entidade)
 
A classe Coordenador representa a entidade coordenador que será persistida no banco de dados. Ela armazena informações pessoais e de contato do coordenador, como nome, CPF, email, além de relacionamentos com telefones, endereços e coordenações.

**Anotações**:
- `@Entity`: Define que a classe será mapeada como uma entidade JPA.
- `@Table(name = "coordenador")`: Define o nome da tabela no banco de dados como "coordenador".
- `@Id`: Define o CPF do coordenador como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o ID.
- `@OneToMany`: Relaciona o coordenador com outros objetos, como endereços e telefones.

**Relacionamentos**:
- **Endereços** (`@OneToMany`): Um coordenador pode ter vários endereços.
- **Telefones** (`@OneToMany`): Um coordenador pode ter vários telefones.
- **Coordenação** (`@ManyToOne`): Um coordenador pode estar associado a uma coordenação, definindo sua área de supervisão.

**Regras de Negócio**:
- O campo CPF é obrigatório e deve ser único.
- Um coordenador deve estar vinculado a pelo menos uma coordenação no momento da criação.
- Um coordenador pode ser ativo ou inativo, e seu status padrão é "ativo" quando é criado.

**Métodos Auxiliares**:
- `addEndereco(Endereco endereco)`: Associa um endereço ao coordenador e define a relação bidirecional.
- `addTelefone(Telefone telefone)`: Adiciona um telefone ao coordenador e configura a relação bidirecional.

---

### CoordenadorRepository.java (Repositório)

O CoordenadorRepository é responsável por interagir diretamente com o banco de dados para a entidade Coordenador. Ele estende o `JpaRepository`, o que facilita a execução de operações de CRUD, além de consultas personalizadas para a busca de coordenadores.

**Métodos**:
- `findAll()`: Retorna todos os coordenadores cadastrados no banco de dados.
- `findById(String id)`: Busca um coordenador pelo CPF.
- `existsByCpf(String cpf)`: Verifica se um coordenador com determinado CPF já está registrado.

**Regras de Negócio**:
- O CPF deve ser único, e a verificação é feita antes da criação de um coordenador.
- As operações de exclusão e atualização são aplicadas apenas se o coordenador não estiver associado a recursos críticos que impeçam essas operações.

---

### CoordenadorService.java (Serviço)

A classe CoordenadorService contém a lógica de negócios relacionada ao coordenador, incluindo a criação, atualização, exclusão e consulta de coordenadores no sistema. Ele aplica regras de negócio e gerencia os relacionamentos com endereços, telefones e coordenações.

**Métodos**:
- `getAllCoordenadores()`: Retorna uma lista de todos os coordenadores cadastrados no sistema.
- `getCoordenadorById(String cpf)`: Busca um coordenador pelo seu CPF.
- `saveCoordenador(CoordenadorDTO coordenadorDTO)`: Cria um novo coordenador com base nos dados fornecidos.
- `updateCoordenador(String id, CoordenadorDTO coordenadorDTO)`: Atualiza as informações de um coordenador existente.
- `deleteCoordenador(String id)`: Remove um coordenador do sistema.

**Regras de Negócio**:
- O CPF deve ser único, e a verificação é feita antes da criação.
- O coordenador precisa estar associado a uma coordenação no momento da criação.
- O status do coordenador é definido como ativo no momento da criação.
- Endereços e telefones são opcionalmente associados ao coordenador.

---

### CoordenadorDTO.java (DTO)

O CoordenadorDTO é um Data Transfer Object usado para enviar e receber dados de coordenadores através da API. Ele abstrai as informações mais complexas, como relacionamentos, e simplifica as operações de leitura e escrita.

**Atributos Principais**:
- **CPF**: Identificação única do coordenador.
- **Nome**: Nome completo do coordenador.
- **Email**: Endereço de email do coordenador.
- **Telefones**: Lista de números de telefone associados.
- **Endereços**: Lista de endereços associados.
- **Status**: Indica se o coordenador está ativo ou inativo.
- **IdCoordenacao**: Identificação da coordenação a qual o coordenador está vinculado.

---

### CoordenadorController.java (Controlador)
 
O CoordenadorController expõe os endpoints REST que permitem a interação com os dados de coordenadores. Ele facilita a criação, leitura, atualização e exclusão de coordenadores no sistema, aplicando as validações necessárias e chamando os métodos do CoordenadorService.

**Anotações**:
- `@RestController`: Define que a classe é um controlador REST.
- `@RequestMapping("/coordenadores")`: Define a rota base para as operações relacionadas a coordenadores.
- `@Tag(name = "Coordenador", description = "Gerenciamento dos Coordenadores")`: Agrupa as operações relacionadas a coordenadores na documentação Swagger.

### Rotas (Endpoints):

#### GET
- `/coordenadores`: Lista todos os coordenadores registrados no sistema.
- `/coordenadores/{cpf}`: Retorna as informações detalhadas de um coordenador com base no CPF fornecido.

#### POST
- `/coordenadores`: Cria um novo coordenador com base nos dados fornecidos no corpo da requisição.

**Regras de Negócio**:
- O CPF deve ser único.
- O coordenador precisa estar associado a uma coordenação.

#### PUT
- `/coordenadores/{cpf}`: Atualiza as informações de um coordenador existente.

**Regras de Negócio**:
- Verifica se o coordenador existe e aplica as atualizações fornecidas.

#### DELETE
- `/coordenadores/{cpf}`: Remove um coordenador do sistema com base no CPF.

**Regras de Negócio**:
- Verifica se o coordenador existe e se pode ser excluído, removendo-o do banco de dados.

---

## Conclusão

O package coordenador é responsável por todas as operações relacionadas aos coordenadores no sistema. A entidade Coordenador reflete suas informações no banco de dados, enquanto o CoordenadorService aplica a lógica de negócio e garante que as regras sejam respeitadas. O CoordenadorController expõe as APIs REST para facilitar a interação com os dados, permitindo a criação, consulta, atualização e remoção de coordenadores.


---


# Package Disciplina

## Entidade Disciplina.java

A entidade Disciplina representa a disciplina acadêmica no sistema. Cada disciplina é vinculada a turmas e, opcionalmente, a professores.

### Anotações
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "disciplina")`: Define o nome da tabela como "disciplina".
- `@Id`: Define o campo id como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o ID da disciplina.

### Atributos Principais
- **Nome**: Nome da disciplina.
- **Carga Horária**: Representa o total de horas que uma disciplina terá ao longo do período letivo.

### Relacionamentos
- **TurmaDisciplinaProfessor** (`OneToMany`): A disciplina pode estar associada a várias turmas e professores, por meio da entidade intermediária TurmaDisciplinaProfessor.

### Regras de Negócio
- O nome da disciplina é obrigatório e deve ser único.
- A carga horária deve ser positiva e válida para os cursos.

---

## DisciplinaRepository.java (Repositório)

O repositório DisciplinaRepository é responsável pela persistência de dados e consultas da entidade Disciplina no banco de dados. Ele herda da interface JpaRepository, permitindo operações de CRUD (criação, leitura, atualização e exclusão).

### Métodos
- `findAll()`: Retorna todas as disciplinas cadastradas no sistema.
- `findById(Long id)`: Busca uma disciplina específica pelo seu ID.

### Regras de Negócio
- O nome da disciplina deve ser único.
- Não deve ser possível deletar uma disciplina que esteja associada a uma turma ou professor.

---

## DisciplinaService.java (Serviço)

A classe DisciplinaService contém a lógica de negócio relacionada à disciplina. Ela realiza a intermediação entre o controlador e o repositório, além de aplicar as regras de negócio na criação, atualização e exclusão de disciplinas.

### Métodos
- `getAllDisciplinas()`: Retorna uma lista de todas as disciplinas cadastradas no banco de dados e converte as entidades para DisciplinaGetDTO.
- `getDisciplinaById(Long id)`: Busca uma disciplina específica pelo ID e retorna suas informações detalhadas. Lança exceção se a disciplina não for encontrada.
- `saveDisciplina(DisciplinaDTO disciplinaDTO)`: Persiste uma nova disciplina no banco de dados.

### Regras de Negócio
- O nome da disciplina deve ser único.
- A disciplina pode ser associada a uma turma e, opcionalmente, a um professor.

- `updateDisciplina(Long id, DisciplinaDTO disciplinaDTO)`: Atualiza uma disciplina existente no banco de dados.
- `deleteDisciplina(Long id)`: Remove uma disciplina do banco de dados.

Regras de negócio:
- A disciplina só pode ser deletada se não houver vínculos obrigatórios com turmas ou professores.

---

## DTOs

### DisciplinaDTO (Data Transfer Object)
Este DTO é usado para transferir os dados principais de uma disciplina nas operações de criação e atualização. 

**Atributos**:
- Nome: Nome da disciplina.
- Carga Horária: Carga horária da disciplina.
- TurmaId: ID da turma associada à disciplina.
- ProfessorId: (Opcional) ID do professor associado à disciplina.

### DisciplinaGetDTO
DTO utilizado para retornar as informações detalhadas de uma disciplina. 

**Atributos**:
- Nome: Nome da disciplina.
- Carga Horária: Carga horária da disciplina.
- Nome da Turma: Nome da turma associada (se houver).
- Nome do Professor: Nome do professor associado (se houver).

### DisciplinaResumidaDTO
DTO resumido utilizado para retornar dados simplificados da disciplina, como nome e carga horária.

---

## DisciplinaController.java (Controlador)

O DisciplinaController expõe os endpoints REST para interagir com as disciplinas. Ele recebe as requisições HTTP, aplica as validações necessárias e interage com o DisciplinaService para execução das operações.

### Rotas (Endpoints)

#### GET
- `/disciplinas`: Retorna uma lista de todas as disciplinas.

**Regras de negócio**:
- Lista todas as disciplinas com informações resumidas.

- `/disciplinas/{id}`: Retorna os detalhes de uma disciplina específica.

**Validações**:
- Se o ID fornecido não existir, retorna 404 (Not Found).

#### POST
- `/disciplinas`: Cria uma nova disciplina.

**Regras de negócio**:
- O nome da disciplina deve ser único.
- A disciplina pode ser associada a uma turma e, opcionalmente, a um professor.

#### PUT
- `/disciplinas/{id}`: Atualiza uma disciplina existente.

**Regras de negócio**:
- O ID da disciplina deve ser válido.
- As associações anteriores são removidas antes de aplicar as novas associações de turma e professor.

#### DELETE
- `/disciplinas/{id}`: Remove uma disciplina existente.

**Regras de negócio**:
- A disciplina só pode ser deletada se não estiver associada a uma turma ou professor.

---

## Tratamento de Erros

- **400 Bad Request**: Erros de validação de dados fornecidos, como nome duplicado ou carga horária inválida.
- **404 Not Found**: Quando uma disciplina não é encontrada pelo ID.
- **500 Internal Server Error**: Erros inesperados no servidor durante a manipulação de disciplinas.

---

## Conclusão

O package disciplina oferece todas as funcionalidades necessárias para a gestão de disciplinas no sistema, garantindo que sejam corretamente associadas a turmas e professores. A lógica de negócios é implementada no DisciplinaService, que lida com regras como a unicidade dos nomes e a exclusão segura de disciplinas. O DisciplinaController disponibiliza uma interface REST para que outros serviços ou aplicações possam interagir com esses dados de forma eficiente.


---


# Package Endereco

O package `endereco` é responsável por representar e armazenar os dados de endereço no sistema. Apesar de não possuir serviços ou controladores próprios, o package é amplamente utilizado e acessado por outras entidades, como Aluno, Professor, Coordenador e Coordenação, para armazenar e gerenciar os endereços associados a esses usuários e entidades.

Este package implementa a classe `Endereco` e seu respectivo DTO (Data Transfer Object), que facilitam a manipulação dos dados de endereço tanto na aplicação quanto nas interações entre camadas.

### Estrutura do Package

O package `endereco` é composto pelas seguintes classes principais:
- `Endereco.java` (Entidade)
- `EnderecoDTO.java` (Objeto de Transferência de Dados)

## Entidade Endereco.java

A entidade `Endereco` é responsável por armazenar as informações detalhadas sobre o endereço, como CEP, rua, número, bairro, cidade e estado. Cada endereço pode ser associado a diversas outras entidades do sistema, como alunos, professores, coordenadores e coordenações, refletindo a flexibilidade de uso dessa entidade.

### Anotações
- `@Entity`: Define que a classe representa uma entidade JPA, mapeada para o banco de dados.
- `@Table(name = "endereco")`: Define que a tabela associada a essa entidade será chamada de "endereco".
- `@Id`: Define o campo `id_endereco` como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o ID do endereço no banco de dados.

### Atributos Principais
- **id_endereco**: Chave primária que identifica exclusivamente um endereço.
- **cep**: O código postal (CEP) do endereço.
- **rua**: O nome da rua ou avenida onde o endereço está localizado.
- **numero**: O número do imóvel.
- **bairro**: O bairro onde o endereço está localizado.
- **cidade**: O nome da cidade.
- **estado**: O estado ou unidade federativa.

### Relacionamentos

A entidade `Endereco` possui relacionamentos de `ManyToOne` com várias outras entidades, sendo elas:
- **Aluno**: Relacionamento com a entidade `Aluno`, indicando que um endereço pode estar vinculado a um aluno.
- **Professor**: Relacionamento com a entidade `Professor`, permitindo a associação de um endereço a um professor.
- **Coordenador**: Relacionamento com a entidade `Coordenador`, para associar o endereço a um coordenador.
- **Coordenação**: Relacionamento com a entidade `Coordenacao`, indicando que um endereço pode estar vinculado à coordenação.

### Regras de Negócio
- O endereço deve conter informações válidas e coerentes, como o CEP sendo composto por 8 a 9 caracteres, e os campos rua, bairro, cidade e estado respeitando limites mínimos e máximos de caracteres.
- Cada endereço pode ser associado a um ou mais alunos, professores, coordenadores ou coordenações, garantindo a reutilização de um mesmo endereço em múltiplas entidades, se necessário.

### Métodos Importantes
- `hashCode()` e `equals()`: Esses métodos são implementados para garantir que as comparações entre objetos de endereço sejam baseadas apenas no ID, evitando possíveis problemas de ciclo nos relacionamentos.

---

## EnderecoDTO.java (Data Transfer Object)

O `EnderecoDTO` é utilizado para transferir os dados de endereço de forma simplificada e eficiente entre as diferentes camadas da aplicação. Ele é utilizado principalmente quando dados de endereço precisam ser fornecidos ou recebidos pelas entidades controladoras (como AlunoController, ProfessorController, etc.).

### Anotações
- `@Builder`: Permite a construção de objetos `EnderecoDTO` de maneira fluida, utilizando o padrão Builder.
- `@Data`: Inclui automaticamente métodos como getters, setters, equals, hashCode e toString.
- `@JsonIgnoreProperties`: Indica que as propriedades relacionadas a outras entidades (como aluno, professor, coordenador, coordenacao) devem ser ignoradas durante a serialização/deserialização JSON, evitando possíveis loops ou informações irrelevantes no DTO.

### Atributos
- **cep**: Código postal do endereço.
- **rua**: Nome da rua.
- **numero**: Número do endereço.
- **bairro**: Bairro onde o endereço está localizado.
- **cidade**: Cidade do endereço.
- **estado**: Estado ou unidade federativa do endereço.

### Utilização

O `EnderecoDTO` é amplamente utilizado quando é necessário transmitir ou exibir os dados de endereço para outras entidades. Por exemplo:
- Quando um aluno é registrado ou atualizado, o endereço do aluno é gerenciado por meio do `EnderecoDTO`.
- O mesmo ocorre para professores, coordenadores e coordenações, que podem ter seus endereços manipulados utilizando este DTO.


---


# Package presencas

O package presencas é responsável por gerenciar as informações de presença dos alunos no sistema, permitindo o registro, consulta, atualização e exclusão dessas informações. As presenças são vinculadas a um aluno, disciplina, turma e professor, e o pacote expõe APIs REST que possibilitam a interação com esses dados.

## Presenca.java (Entidade)

A classe Presenca representa a entidade de presença, que registra a frequência dos alunos em aulas específicas. Cada instância dessa entidade está associada a um aluno, uma turma, uma disciplina e um professor.

### Anotações:
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "presenca")`: Define o nome da tabela como presenca.
- `@Id`: Define o campo id como chave primária.
- `@ManyToOne`: Relaciona uma presença com as entidades Aluno e TurmaDisciplinaProfessor.

### Relacionamentos:
- **Aluno (`@ManyToOne`)**: Cada registro de presença pertence a um aluno específico.
- **TurmaDisciplinaProfessor (`@ManyToOne`)**: Cada registro de presença está vinculado a uma combinação de turma, disciplina e professor.

### Atributos Principais:
- **Data**: Registra a data da aula.
- **Presença**: Um valor booleano que indica se o aluno estava presente (`true`) ou ausente (`false`).

### Regras de Negócio:
- Cada registro de presença deve estar associado a um aluno e a uma aula (turma, disciplina e professor).
- O campo de presença é um booleano que registra a presença ou ausência do aluno em uma data específica.

## PresencaRepository.java (Repositório)

O PresencaRepository é responsável por realizar operações de persistência e consulta relacionadas às presenças no banco de dados. Ele estende JpaRepository, permitindo operações CRUD e consultas personalizadas para buscar presenças de alunos, disciplinas, professores e turmas.

### Métodos:
- `findByAluno(Aluno aluno)`: Retorna todas as presenças associadas a um aluno específico.
- `findByAlunoAndTurmaDisciplinaProfessor_Disciplina(Aluno aluno, Disciplina disciplina)`: Retorna as presenças de um aluno em uma disciplina específica.
- `findByTurmaDisciplinaProfessor_Professor(Professor professor)`: Busca todas as presenças relacionadas a um professor específico.

### Regras de Negócio:
- A presença deve ser única por aluno e aula (definida pela combinação de turma, disciplina e professor).
- Consultas podem ser filtradas por aluno, disciplina ou professor.

## PresencaService.java (Serviço)

A classe PresencaService gerencia a lógica de negócios associada à presença dos alunos. Ela é responsável por calcular, registrar e buscar informações de presença, além de permitir operações de CRUD.

### Anotações:
- `@Service`: Define a classe como um serviço do Spring, contendo a lógica de negócio.
- `@Transactional`: Indica que as operações realizadas nos métodos de serviço são tratadas como transações atômicas.

### Métodos:
- `salvarPresenca(Long idAluno, Long idTurma, Long idDisciplina, String idProfessor, PresencaInputDTO presencaInputDTO)`
    - Salva uma nova presença ou atualiza uma presença existente. A presença é vinculada ao aluno e à aula (definida por turma, disciplina e professor).

#### Regras de Negócio:
- O aluno deve existir no banco de dados.
- A presença deve estar associada a uma aula (turma, disciplina, professor).

- `buscarPresencaPorId(Long idAluno, Long idPresenca)`
    - Busca uma presença específica por ID, garantindo que a presença está vinculada ao aluno correto.

- `listarPresencasPorAluno(Long idAluno)`
    - Lista todas as presenças registradas para um aluno específico.

- `listarPresencasPorAlunoEDisciplina(Long idAluno, Long idDisciplina)`
    - Lista as presenças de um aluno em uma disciplina específica.

- `listarPresencasEmitidasPorProfessor(String idProfessor)`
    - Lista todas as presenças registradas por um professor específico.

- `deletarPresenca(Long idAluno, Long idPresenca)`
    - Remove um registro de presença, garantindo que a presença pertence ao aluno informado.

## PresencaController.java (Controlador)

O PresencaController expõe os endpoints REST que permitem o gerenciamento das presenças dos alunos. Ele lida com a criação, consulta, atualização e exclusão de registros de presença, utilizando o PresencaService para realizar as operações.

### Anotações:
- `@RestController`: Define a classe como um controlador REST.
- `@RequestMapping("/presencas")`: Define a rota base para todas as operações relacionadas às presenças.
- `@Tag(name = "Presenças", description = "Operações relacionadas às presenças dos alunos")`: Agrupa as operações relacionadas às presenças na documentação do Swagger.

### Rotas (Endpoints):
- **POST** `/aluno/{idAluno}/turma/{idTurma}/disciplina/{idDisciplina}/professor/{idProfessor}`
    - Cria uma nova presença para um aluno em uma aula específica.

#### Validações:
- O aluno, a turma, a disciplina e o professor devem existir.
- Os dados fornecidos no `PresencaInputDTO` devem ser válidos.

- **PUT** `/presencas/{id}/aluno/{idAluno}/turma/{idTurma}/disciplina/{idDisciplina}/professor/{idProfessor}`
    - Atualiza uma presença existente.

#### Validações:
- A presença deve existir no banco de dados.
- Os dados fornecidos no `PresencaInputDTO` devem seguir as regras de negócio.

- **GET** `/presencas/{id}/aluno/{idAluno}`
    - Busca uma presença específica por ID.

#### Validações:
- A presença deve estar vinculada ao aluno informado.
- Se a presença não for encontrada, retorna `404 Not Found`.

- **GET** `/aluno/{idAluno}`
    - Lista todas as presenças de um aluno específico.

- **GET** `/aluno/{idAluno}/disciplina/{idDisciplina}`
    - Lista as presenças de um aluno em uma disciplina específica.

- **GET** `/professor/{idProfessor}`
    - Lista todas as presenças registradas por um professor específico.

- **DELETE** `/presencas/{id}/aluno/{idAluno}`
    - Deleta uma presença.

#### Validações:
- A presença deve estar vinculada ao aluno informado.
- Se a presença não for encontrada, retorna `404 Not Found`.

### Tratamento de Erros:
- **400 Bad Request**: Utilizado para erros de validação de dados.
- **404 Not Found**: Utilizado quando a presença ou o recurso solicitado não é encontrado no banco de dados.
- **500 Internal Server Error**: Utilizado em casos de erros inesperados no servidor.

O pacote `presencas` garante o correto gerenciamento das presenças dos alunos, aplicando regras de negócio específicas para garantir a integridade dos dados e a correta vinculação entre aluno, disciplina, turma e professor.


---


## Considerações Finais

O package `endereco` não possui serviços ou controladores próprios, pois suas funcionalidades são acessadas e manipuladas pelas outras entidades do sistema, como Aluno, Professor, Coordenador e Coordenação. Isso ocorre porque um endereço é considerado um dado auxiliar para essas entidades, e seu gerenciamento é feito por meio dos respectivos serviços e controladores dessas entidades principais.

Este package garante a reutilização de endereços por várias entidades, centralizando e padronizando a forma como essas informações são tratadas no sistema.


---

# Package Professor

O package `professor` é responsável por gerenciar todas as operações relacionadas aos professores no sistema. Ele inclui a criação, atualização, listagem e exclusão de professores, além de permitir associar professores a turmas, disciplinas e coordenadorias. As funcionalidades são acessadas através de endpoints REST definidos no `ProfessorController`, e a lógica de negócios está centralizada no `ProfessorService`.

### Este package contém as principais classes:
- **ProfessorService**: Implementa a lógica de negócio para a manipulação dos professores.
- **ProfessorController**: Define os endpoints REST para interação com as operações relacionadas a professores.

---


## Entidade Professor.java

A entidade `Professor` define o modelo de dados dos professores no sistema. Ela inclui atributos como CPF, nome, data de nascimento, e possui relacionamentos com Coordenação, Endereços, Telefones, Turmas e Disciplinas.

### Atributos Principais
- **CPF**: Identificador único do professor.
- **Nome**: Nome e sobrenome do professor.
- **E-mail**: Endereço de e-mail para contato.
- **Coordenação**: Associação opcional com uma coordenação.
- **Status**: Indica se o professor está ativo ou inativo.

### Relacionamentos
- **Coordenação**: Um professor pode ser associado a uma coordenação, sendo opcional.
- **Endereços e Telefones**: O professor pode ter múltiplos endereços e telefones.
- **Turmas e Disciplinas**: Professores podem ser associados a várias turmas e disciplinas por meio da entidade intermediária `TurmaDisciplinaProfessor`.

---


# ProfessorRepository.java (Repositório)

O ProfessorRepository é responsável pela persistência de dados e consultas da entidade Professor no banco de dados. Ele herda da interface `JpaRepository`, o que facilita a execução de operações de CRUD (Create, Read, Update, Delete) sem a necessidade de definir SQL manualmente.

## Métodos

- **findById(String cpf)**: 
  - Busca um professor específico pelo CPF, que é a chave primária da entidade.
  - **Tipo de retorno**: `Optional<Professor>`, que encapsula a entidade encontrada ou retorna vazio se não existir.

- **existsByCpf(String cpf)**: 
  - Verifica se já existe um professor com o CPF fornecido no banco de dados.
  - **Tipo de retorno**: `boolean`, retornando `true` se o CPF já estiver registrado, ou `false` se não estiver.

## Regras de Negócio
- O CPF de um professor deve ser único, garantindo que não existam duplicidades no sistema.
- Professores podem ser buscados pelo CPF para realizar operações como atualização ou exclusão.
- A validação de existência pelo CPF garante que duplicidades sejam evitadas antes de inserir um novo registro no banco de dados.


---


## ProfessorService.java (Serviço)

O `ProfessorService` é o responsável por implementar a lógica de negócios relacionada aos professores. Ele utiliza os repositórios para acessar e manipular os dados no banco e expõe métodos que são consumidos pelo controlador.

### Métodos Principais
1. **saveProfessor(ProfessorDTO professorDTO)**
   - Cria um novo professor no sistema.
   - Associa o professor a uma coordenação (se fornecida), endereços, telefones, turmas e disciplinas.
   - **Validação**: Verifica se o CPF já está registrado para evitar duplicações.

2. **updateProfessor(String cpf, ProfessorDTO professorDTO)**
   - Atualiza as informações de um professor existente.
   - Permite a atualização de dados básicos como nome, gênero, data de nascimento, além de endereços, telefones, e suas associações com turmas e disciplinas.

3. **deleteProfessor(String cpf)**
   - Exclui um professor do sistema com base no CPF.

4. **getAllProfessores()**
   - Retorna uma lista de todos os professores registrados no sistema, com suas informações resumidas.

5. **getProfessorById(String cpf)**
   - Busca um professor específico pelo CPF e retorna suas informações detalhadas.

### Métodos Auxiliares
- **associateEnderecos(ProfessorDTO professorDTO, Professor professor)**: Associa e salva os endereços de um professor.
- **associateTelefones(ProfessorDTO professorDTO, Professor professor)**: Associa e salva os telefones de um professor.
- **associateTurmasDisciplinas(ProfessorDTO professorDTO, Professor professor)**: Associa o professor a turmas e disciplinas.
- **convertToDto(Professor professor)**: Converte um objeto `Professor` para o DTO `ProfessorResumidoDTO`, facilitando a transferência de dados.

---

## ProfessorController.java (Controlador)

O `ProfessorController` expõe os endpoints REST para gerenciar as operações relacionadas aos professores. Ele utiliza o `ProfessorService` para realizar as operações de criação, listagem, atualização e exclusão de professores.

### Endpoints Principais
1. **GET /professores**
   - Lista todos os professores cadastrados no sistema.
   - **Resposta**: Lista de `ProfessorResumidoDTO`.

2. **GET /professores/{cpf}**
   - Busca um professor pelo CPF.
   - **Parâmetro**: CPF do professor.
   - **Resposta**: Detalhes do professor em `ProfessorResumidoDTO`.

3. **POST /professores**
   - Cria um novo professor.
   - **Corpo da Requisição**: Dados do professor no formato `ProfessorDTO`.
   - **Resposta**: Professor criado no formato `ProfessorResumidoDTO`.

4. **PUT /professores/{cpf}**
   - Atualiza um professor existente com base no CPF.
   - **Parâmetro**: CPF do professor.
   - **Corpo da Requisição**: Dados atualizados do professor no formato `ProfessorDTO`.
   - **Resposta**: Professor atualizado em `ProfessorResumidoDTO`.

5. **DELETE /professores/{cpf}**
   - Deleta um professor com base no CPF.
   - **Parâmetro**: CPF do professor.
   - **Resposta**: Código de status HTTP 204 (No Content).

---

## Métodos Relacionados a Conceitos

Além de gerenciar as operações de professores, o `ProfessorController` também inclui endpoints que permitem aos professores adicionar e atualizar conceitos dos alunos em disciplinas e turmas específicas, utilizando o `ConceitoService`.

---

## Considerações Finais

O package `professor` implementa uma arquitetura limpa e estruturada para o gerenciamento dos professores no sistema. Com a ajuda dos DTOs, repositórios e métodos transacionais, ele garante que a lógica de negócios seja tratada de forma eficiente e segura. Além disso, as operações relacionadas a turmas, disciplinas e coordenação são integradas, proporcionando uma visão completa do professor no contexto educacional.


---


# Package Responsável

O package `responsavel` gerencia as informações relacionadas aos responsáveis dos alunos, incluindo seus dados pessoais, como CPF, nome, grau de parentesco, e suas associações com telefones. Sem serviços e controladores próprios, o pacote é acessado e manipulado por meio de outras entidades, principalmente pela entidade Aluno.

Neste pacote, o Responsável está diretamente associado ao Aluno e pode ter múltiplos telefones associados, seguindo uma relação de um para muitos. O package foca na representação da entidade responsável e em suas relações com outras entidades do sistema.

---

## Estrutura do Package

O package `responsavel` contém as seguintes classes principais:

- **Responsavel.java**: Representa a entidade responsável, com atributos como CPF, nome e grau de parentesco. A classe também gerencia a relação entre os responsáveis e seus telefones.
- **ResponsavelDTO.java**: Um objeto de transferência de dados (DTO) usado para simplificar a transferência de informações de responsáveis, principalmente em consultas associadas aos alunos.

Apesar de não possuir serviços e controladores próprios, o package é essencial para a representação dos dados e para o relacionamento dos responsáveis com alunos e telefones.

---

## Entidade Responsavel.java

A entidade `Responsavel` define os responsáveis que podem estar associados aos alunos no sistema. Um responsável é uma pessoa (como pai, mãe ou tutor legal) que tem um relacionamento formal com um ou mais alunos. O responsável também pode possuir múltiplos telefones para contato.

### Atributos Principais
- **ID**: Chave primária da entidade, gerada automaticamente.
- **CPF**: CPF do responsável, obrigatório e único.
- **Nome e Sobrenome**: Nome completo do responsável.
- **Grau de Parentesco**: Especifica a relação familiar do responsável com o aluno (ex.: Pai, Mãe, Tio, Tutor, etc.).

### Relacionamentos
- **Aluno**: Um responsável pode estar associado a um ou mais alunos. A relação é `ManyToOne`, o que significa que muitos responsáveis podem estar relacionados a um único aluno.
- **Telefones**: Um responsável pode ter vários telefones associados. Esta relação é `OneToMany`, garantindo que, ao excluir um responsável, os telefones também sejam excluídos automaticamente (graças ao `CascadeType.ALL` e `orphanRemoval = true`).

### Métodos Auxiliares
- **addTelefone(Telefone telefone)**: Este método permite adicionar um telefone ao conjunto de telefones de um responsável e garantir que a relação bidirecional entre o telefone e o responsável seja mantida. Isso significa que, ao adicionar um telefone, o telefone também terá seu atributo `responsavel` configurado corretamente.

### Exemplo de Relacionamento com Aluno
Um Aluno pode ter um ou mais responsáveis. Essa relação é essencial para sistemas educacionais, onde o contato com o responsável é necessário para questões administrativas, como comunicação sobre o desempenho do aluno ou autorização de eventos.

### Exemplo de Relacionamento com Telefones
Um responsável pode ter vários telefones cadastrados, que podem ser utilizados para contato emergencial ou diário. O sistema garante que, ao remover um responsável, seus telefones sejam removidos automaticamente.

---

## ResponsavelDTO.java (Data Transfer Object)

A classe `ResponsavelDTO` é usada para transferir os dados dos responsáveis de forma eficiente entre as camadas da aplicação. Ao utilizar DTOs, evitamos a exposição direta das entidades internas do sistema, garantindo mais flexibilidade e segurança na comunicação entre os diferentes módulos.

### Atributos Principais
- **Nome e Sobrenome**: Dados do nome completo do responsável.
- **CPF**: CPF do responsável.
- **Telefones**: Lista de telefones associados ao responsável, utilizando o `TelefoneDTO` para simplificar a transferência de dados.
- **Grau de Parentesco**: Especifica o relacionamento entre o responsável e o aluno.

Este DTO é frequentemente utilizado em operações que envolvem a exibição de dados de alunos, já que os responsáveis estão diretamente associados a eles.

---

## Considerações Finais

O package `responsavel` é um componente fundamental para a representação dos dados de responsáveis dentro do sistema educacional. Embora não possua serviços e controladores próprios, ele é acessado principalmente através da entidade Aluno, garantindo que informações críticas sobre os responsáveis sejam gerenciadas de forma eficaz.

Assim como o package `endereco`, o `responsavel` é manipulado indiretamente por outras entidades, o que torna sua estrutura mais simples, focando em seus atributos, relacionamentos e métodos auxiliares.


---

# Package Telefone

O package `telefone` é responsável pela representação dos telefones associados a diversas entidades do sistema, como Aluno, Professor, Coordenador, Coordenação e Responsável. Ele gerencia o armazenamento e a validação de dados de telefones, como o código de área (DDD) e o número de telefone. Embora não possua serviços e controladores próprios, o package é amplamente utilizado por outras entidades do sistema para gerenciar informações de contato.

O package `telefone` segue uma estrutura simples, sendo manipulado pelas outras entidades do sistema, que gerenciam as operações de CRUD sobre os telefones.

---

## Estrutura do Package

O package `telefone` contém as seguintes classes principais:

- **Telefone.java**: Representa a entidade de telefone, responsável por armazenar o DDD e o número, além de manter relações com outras entidades do sistema.
- **TelefoneDTO.java**: Um Data Transfer Object (DTO) que simplifica o transporte de dados relacionados a telefones entre as camadas da aplicação.

Assim como o package `endereco`, o package `telefone` é manipulado por outras entidades, mas possui uma estrutura própria de validações e relacionamentos.

---

## Entidade Telefone.java

A entidade `Telefone` gerencia as informações dos telefones no sistema, associando-os a entidades como Aluno, Professor, Coordenador, Coordenação e Responsável. Ela possui atributos que garantem a validação de informações como o DDD e o número do telefone, além de manter o relacionamento adequado com outras entidades.

### Atributos Principais

- **ID**: Chave primária da entidade, gerada automaticamente.
- **DDD**: O código de área do telefone, obrigatório, com tamanho fixo de 2 dígitos.
- **Número**: O número de telefone, obrigatório, com tamanho entre 8 e 9 dígitos.

### Validações

- O **DDD** deve conter exatamente 2 dígitos, seguindo a padronização de códigos de área no Brasil.
- O **Número** deve conter entre 8 e 9 dígitos, garantindo que o número seja válido tanto para números fixos quanto móveis.

### Relacionamentos

A entidade `Telefone` possui várias associações `ManyToOne`, o que significa que um telefone pode pertencer a apenas uma entidade (Aluno, Professor, Coordenador, Coordenação ou Responsável) por vez. O relacionamento é bidirecional, mas a serialização para JSON (por exemplo, em APIs) omite os dados dessas associações para evitar ciclos de referência e problemas de performance.

### Entidades Relacionadas

- **Aluno**: Um telefone pode estar associado a um único aluno.
- **Professor**: Um telefone pode pertencer a um professor.
- **Coordenador**: Um telefone pode estar associado a um coordenador.
- **Coordenação**: Um telefone pode ser relacionado diretamente a uma coordenação.
- **Responsável**: Um telefone pode estar vinculado a um responsável.

Esses relacionamentos permitem que qualquer uma dessas entidades tenha um ou mais telefones associados a elas. Como os telefones são manipulados diretamente por essas entidades, não há necessidade de um serviço ou controlador exclusivo para telefones.

---

## Métodos Auxiliares

- **setResponsavel(Responsavel responsavel)**: Este método estabelece a relação bidirecional entre um telefone e um responsável. Ele é utilizado quando um telefone é associado a um responsável, garantindo que ambos os objetos reconheçam a relação entre si.

---

## TelefoneDTO.java (Data Transfer Object)

O `TelefoneDTO` é um objeto de transferência de dados usado para simplificar o transporte das informações de telefone entre as camadas da aplicação. Ele serve para exibir e transportar apenas os dados relevantes do telefone (DDD e número) sem incluir detalhes sobre os relacionamentos com outras entidades.

### Atributos Principais

- **DDD**: O código de área do telefone.
- **Número**: O número do telefone.

O DTO é essencial para garantir a comunicação eficiente entre as camadas do sistema, isolando as entidades internas da exposição direta em APIs e interfaces de usuário.

---

## Considerações Finais

O package `telefone` desempenha um papel crucial ao permitir que várias entidades do sistema (como Aluno, Professor, Coordenador, Coordenação e Responsável) possam gerenciar e armazenar seus números de telefone de forma organizada. Mesmo sem possuir serviços ou controladores próprios, ele é acessado e manipulado pelas entidades mencionadas, seguindo uma estrutura de relacionamento clara e validada.

Esse modelo de encapsulamento garante a integridade dos dados de contato no sistema, permitindo que os telefones sejam facilmente acessados e gerenciados por meio de outras entidades, ao mesmo tempo que mantém a simplicidade e clareza no design do sistema.


---


# Package Turma

## Entidade Turma.java

A entidade Turma representa uma turma no sistema acadêmico. Cada turma é composta por atributos como o ano letivo, turno, status e coordenação, além de associações com alunos, disciplinas e professores.

### Anotações
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "turma")`: Define o nome da tabela como "turma".
- `@Id`: Define o campo `id` como chave primária.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Gera automaticamente o ID da turma.

### Atributos Principais
- **Ano Letivo**: Representa o ano em que a turma está ativa.
- **Turno**: Define o período em que as aulas ocorrem (manhã, tarde, noite).
- **Status**: Indica se a turma está ativa ou inativa.
- **Coordenação**: Associação com a entidade Coordenação, responsável pela gestão da turma.

### Relacionamentos
- **Alunos (OneToMany)**: A turma pode conter vários alunos.
- **TurmaDisciplinaProfessor (OneToMany)**: A turma pode estar associada a várias disciplinas e professores por meio da entidade intermediária TurmaDisciplinaProfessor.

### Regras de Negócio
- Cada turma deve ter uma coordenação associada.
- O nome da turma é gerado automaticamente com base no seu ID e segue o formato "Turma {ID}".
- A turma só pode ser excluída se não houver vínculos obrigatórios com disciplinas ou professores.

## TurmaRepository.java (Repositório)

O TurmaRepository é responsável pela persistência e consulta das turmas no banco de dados. Ele estende JpaRepository, o que facilita a execução de operações CRUD (Create, Read, Update, Delete) sem a necessidade de definir SQL manualmente.

### Métodos
- `findById(Long id)`: Busca uma turma específica pelo seu ID.
- `findAllIds()`: Retorna uma lista com todos os IDs das turmas cadastradas.

### Regras de Negócio
- A turma pode ser buscada por seu ID para ser atualizada ou excluída.
- A listagem de IDs permite operações otimizadas quando o carregamento completo da entidade não é necessário.

## TurmaService.java (Serviço)

A classe TurmaService contém a lógica de negócios relacionada à manipulação de turmas. O serviço intermedia a comunicação entre o repositório e o controlador, gerenciando as operações de criação, atualização, exclusão e consulta de turmas, além de lidar com suas associações a alunos, disciplinas e professores.

### Métodos
- `getAllTurmas()`: Retorna uma lista de todas as turmas cadastradas, convertendo as entidades para TurmaDTO.
- `getTurmaById(Long id)`: Busca uma turma específica pelo ID e retorna suas informações detalhadas.
- `saveTurma(TurmaInputDTO turmaDTO)`: Cria uma nova turma no banco de dados e associa seus alunos, disciplinas e professores.
- `updateTurma(Long id, TurmaInputDTO turmaDTO)`: Atualiza uma turma existente, recriando suas associações com alunos, disciplinas e professores.
- `deleteTurma(Long id)`: Exclui uma turma do banco de dados, removendo suas associações antes da exclusão.

### Regras de Negócio
- O nome da turma é gerado automaticamente com base no ID.
- A turma pode ser associada a uma coordenação, alunos, disciplinas e professores.
- A exclusão de uma turma só é permitida se não houver vínculos obrigatórios com disciplinas e professores.

## DTOs

### TurmaDTO (Data Transfer Object)
Este DTO é utilizado para transferir os dados completos de uma turma nas operações de busca, criação e atualização.

### Atributos
- **Nome**: Nome gerado da turma.
- **Ano Letivo**: O ano em que a turma está ativa.
- **Turno**: Turno de aula da turma.
- **Status**: Status (ativo/inativo) da turma.
- **Coordenação**: Nome da coordenação associada.
- **Disciplinas**: Lista de disciplinas associadas à turma.
- **DisciplinasProfessores**: Lista das associações entre disciplinas e professores.
- **Alunos**: Lista de alunos matriculados na turma.

### TurmaInputDTO
DTO utilizado nas operações de criação e atualização de turmas. Contém os dados básicos para definir uma nova turma, além dos IDs de alunos, disciplinas e professores que devem ser associados à turma.

### Atributos
- **Ano Letivo**: O ano em que a turma será criada.
- **Ano Escolar**: O ano escolar da turma.
- **Turno**: Turno de aula da turma.
- **Status**: Status (ativo/inativo) da turma.
- **CoordenaçãoId**: ID da coordenação associada.
- **AlunosIds**: IDs dos alunos a serem associados à turma.
- **DisciplinasProfessores**: Dados que ligam as disciplinas aos professores.

### DisciplinaProfessorDTO
DTO utilizado para associar disciplinas e professores a uma turma. Ele agrupa as disciplinas ensinadas por um determinado professor.

### Atributos
- **ProfessorId**: ID do professor.
- **Nome do Professor**: Nome completo do professor.
- **Email do Professor**: Email do professor.
- **NomesDisciplinas**: Lista de nomes das disciplinas ensinadas pelo professor.

## TurmaController.java (Controlador)

O TurmaController expõe os endpoints REST que permitem a interação com os dados das turmas. Ele recebe as requisições HTTP, aplica as validações necessárias e interage com o TurmaService para executar operações de criação, atualização, exclusão e consulta de turmas.

### Rotas (Endpoints)

#### GET
- `/turmas`: Retorna uma lista de todas as turmas cadastradas.
  - **Regras de negócio**: Retorna informações resumidas de todas as turmas.
- `/turmas/{id}`: Retorna os detalhes de uma turma específica.
  - **Validações**: Se o ID não existir, retorna 404 (Not Found).

#### POST
- `/turmas`: Cria uma nova turma com base nos dados fornecidos.
  - **Regras de negócio**: A coordenação, alunos, disciplinas e professores devem existir e estar válidos.

#### PUT
- `/turmas/{id}`: Atualiza uma turma existente com base no ID.
  - **Validações**: O ID da turma deve ser válido, e suas associações anteriores são removidas antes de criar novas.

#### DELETE
- `/turmas/{id}`: Remove uma turma existente.
  - **Regras de negócio**: A turma só pode ser excluída se não houver vínculos obrigatórios com disciplinas ou professores.

### Tratamento de Erros
- **400 Bad Request**: Quando os dados fornecidos na criação ou atualização são inválidos.
- **404 Not Found**: Quando a turma não é encontrada pelo ID fornecido.
- **500 Internal Server Error**: Para erros inesperados no servidor.

## Conclusão
O package `turma` oferece uma estrutura completa para gerenciar turmas no sistema, incluindo funcionalidades para criação, atualização, listagem e exclusão de turmas. Ele permite associar alunos, disciplinas e professores, garantindo que a turma seja gerenciada conforme as regras de negócio definidas. A lógica de negócios é implementada no `TurmaService`, e o `TurmaController` expõe as funcionalidades via API REST.


---

# Package TurmaDisciplinaProfessor

O package `TurmaDisciplinaProfessor` é responsável por representar o relacionamento entre turmas, disciplinas e professores no sistema. Ele associa essas três entidades, garantindo que uma disciplina seja ministrada por um professor específico em uma turma. A estrutura permite gerenciar e consultar quais disciplinas são ministradas em quais turmas e por quais professores.

## Entidade TurmaDisciplinaProfessor.java

A classe `TurmaDisciplinaProfessor` gerencia o relacionamento entre turmas, disciplinas e professores. Ela cria uma relação intermediária, permitindo que uma turma tenha várias disciplinas ministradas por professores específicos.

### Anotações
- `@Entity`: Define a classe como uma entidade JPA.
- `@Table(name = "turma_disciplina_professor")`: Define o nome da tabela.
- `@ManyToOne`: Define os relacionamentos com as entidades Turma, Disciplina e Professor.
- `@EmbeddedId`: Utiliza uma chave composta para identificar cada relação de forma única.

### Atributos Principais
- **Turma** (`@ManyToOne`): Representa a relação de uma turma com as disciplinas e professores.
- **Disciplina** (`@ManyToOne`): Disciplina ministrada na turma.
- **Professor** (`@ManyToOne`): Professor responsável pela disciplina na turma.

### Regras de Negócio
- Cada associação entre uma turma, disciplina e professor deve ser única.
- Não devem existir relações duplicadas para a mesma combinação de turma, disciplina e professor.

## Classe TurmaDisciplinaProfessorId.java

A classe `TurmaDisciplinaProfessorId` define a chave composta da entidade `TurmaDisciplinaProfessor`, garantindo a unicidade de cada relação.

### Anotações
- `@Embeddable`: Define a classe como um identificador embutido.

### Atributos Principais
- **TurmaId**: ID da turma associada.
- **DisciplinaId**: ID da disciplina associada.
- **ProfessorCpf**: CPF do professor associado.

### Regras de Negócio
- A combinação de `TurmaId`, `DisciplinaId` e `ProfessorCpf` deve ser única.

## DTOs

### TurmaDisciplinaProfessorDTO.java

O `TurmaDisciplinaProfessorDTO` é utilizado para transferir dados de uma associação entre turma, disciplina e professor.

#### Atributos:
- **TurmaId**: ID da turma.
- **DisciplinaId**: ID da disciplina.
- **ProfessorCpf**: CPF do professor associado.

### TurmaDisciplinaProfessorIdDTO.java

O `TurmaDisciplinaProfessorIdDTO` representa a chave composta da associação entre uma turma, disciplina e professor.

#### Atributos:
- **TurmaId**: Identificador único da turma.
- **DisciplinaId**: Identificador único da disciplina.
- **ProfessorCpf**: CPF do professor.

### TurmaDisciplinaProfessorCompletoDTO.java

O `TurmaDisciplinaProfessorCompletoDTO` contém informações detalhadas da relação entre turma, disciplina e professor.

#### Atributos:
- **Nome da Turma**: Nome da turma associada.
- **Nome da Disciplina**: Nome da disciplina associada.
- **Nome do Professor**: Nome completo do professor associado.

## Repositório TurmaDisciplinaProfessorRepository.java

O `TurmaDisciplinaProfessorRepository` é responsável pela persistência e consulta dos relacionamentos entre turmas, disciplinas e professores no banco de dados. Ele herda da interface `JpaRepository`, oferecendo operações de CRUD e consultas personalizadas.

### Métodos
- **findByDisciplinaId(Long disciplinaId)**: Retorna todas as associações de uma disciplina específica.
- **deleteByTurmaId(Long turmaId)**: Remove todas as associações relacionadas a uma turma.

### Regras de Negócio
- Não é possível deletar uma associação de uma turma se existirem registros vinculados que dependam dessa relação.

## Conclusão
O package `TurmaDisciplinaProfessor` é essencial para gerenciar as associações entre turmas, disciplinas e professores. Ele garante que essas relações sejam únicas e que as operações sobre elas sejam realizadas de maneira eficiente. As classes de entidade, DTOs e repositório proporcionam uma estrutura organizada para o gerenciamento acadêmico no sistema.


---


# Package Usuario

## Visão Geral
O package `usuario` contém a classe `Usuario`, que serve como uma superclasse abstrata para outras entidades que representam usuários no sistema, como alunos, professores, coordenadores e responsáveis. A classe define atributos comuns a todos os tipos de usuários, incluindo nome, sobrenome, gênero, data de nascimento e e-mail. Ao ser declarada como uma `@MappedSuperclass`, essa classe permite que outras entidades herdem seus atributos sem que ela própria seja mapeada diretamente para uma tabela no banco de dados.

## Classe Usuario.java

### Descrição
A classe `Usuario` é abstrata e contém atributos e comportamentos comuns a todos os tipos de usuários no sistema. Ela é responsável por armazenar informações básicas como nome, sobrenome, gênero, data de nascimento e email. Além disso, utiliza anotações de validação para garantir que os dados sejam consistentes e corretos.

### Anotações
- `@MappedSuperclass`: Define a classe como uma superclasse mapeada no JPA. Ela não será mapeada diretamente para uma tabela, mas suas subclasses herdarão os atributos e comportamentos.
- `@Data`: Gera automaticamente métodos `getters`, `setters`, `equals`, `hashCode` e `toString` para todos os atributos.
- `@NoArgsConstructor`: Cria automaticamente um construtor sem parâmetros.
- `@AllArgsConstructor`: Cria um construtor com todos os parâmetros.
- `@SuperBuilder`: Facilita a criação de objetos utilizando o padrão Builder, compatível com classes que utilizam herança.

### Atributos Principais
- **nome** (`@Column`, `@NotNull`, `@Size`): Nome do usuário, obrigatório e deve ter entre 3 e 50 caracteres.
- **ultimoNome** (`@Column`, `@NotNull`, `@Size`): Sobrenome do usuário, obrigatório e deve ter entre 3 e 50 caracteres.
- **genero** (`@Column`, `@NotNull`): Gênero do usuário (por exemplo, "Masculino", "Feminino"), obrigatório.
- **data_nascimento** (`@Temporal`, `@Column`, `@NotNull`): Data de nascimento do usuário, obrigatória e armazenada como data no banco.
- **email** (`@Column`, `@NotNull`, `@Email`, `unique = true`): Email do usuário, obrigatório, único e deve seguir o formato de um endereço de e-mail válido.

### Validações
- O nome e o sobrenome devem ter entre 3 e 50 caracteres e não podem ser nulos.
- O gênero é obrigatório.
- A data de nascimento é obrigatória e deve ser armazenada em formato de data.
- O email deve ser único no sistema, seguir um formato válido, e ser obrigatório.

### Regras de Negócio
- A classe `Usuario` não é diretamente instanciada, pois é uma superclasse abstrata. Subclasses, como `Aluno`, `Professor` ou `Coordenador`, devem herdar dessa classe para garantir que os dados essenciais de cada usuário sejam consistentes.
- O campo `email` deve ser único para evitar que dois usuários tenham o mesmo endereço de e-mail.

## Conclusão
O package `usuario` define a estrutura básica de um usuário no sistema através da classe `Usuario`. Ela serve como uma superclasse para todas as outras entidades que representam diferentes tipos de usuários. Com suas anotações de validação e atributos comuns, o `Usuario` garante que informações essenciais como nome, sobrenome, gênero, data de nascimento e email sejam armazenadas de maneira consistente e validada.


---

# Package de Configuração

O package `projeto.integrador3.senac.mediotec.pi3_mediotec` tem um papel fundamental na configuração e inicialização da aplicação. Este package contém classes essenciais para a execução do sistema, bem como configurações de CORS e Swagger para documentar e gerenciar as APIs. Abaixo, detalhamos cada uma dessas classes, suas funções e sua importância.

## Pi3MediotecApplication.java

### Descrição
Esta classe é o ponto de entrada da aplicação Spring Boot. Ela contém o método `main`, que dispara a execução do sistema. A anotação `@SpringBootApplication` é usada para habilitar várias funcionalidades do Spring Boot, como a configuração automática e a varredura de componentes.

### Anotações
- `@SpringBootApplication`: Combina três anotações essenciais do Spring:
  - `@Configuration`: Indica que a classe pode conter definições de Beans.
  - `@EnableAutoConfiguration`: Permite ao Spring Boot configurar automaticamente os componentes da aplicação.
  - `@ComponentScan`: Habilita a varredura de componentes do Spring em todo o package base.

### Método Principal
- **main(String[] args)**: Método principal da aplicação. Ele utiliza o `SpringApplication.run` para iniciar o contexto do Spring e executar a aplicação.

---

## SwaggerConfig.java

### Descrição
A classe `SwaggerConfig` configura a integração com o Swagger/OpenAPI, uma ferramenta amplamente utilizada para documentar APIs REST. Ela customiza a documentação gerada para a API, oferecendo informações detalhadas como o nome da aplicação, sua versão e contatos.

### Anotações
- `@Configuration`: Indica que essa classe contém configurações do Spring.

### Métodos
- **customOpenAPI()**: Configura o Swagger/OpenAPI para fornecer uma documentação interativa da API.
- **Info**: Fornece informações sobre o sistema, como o título, versão e uma descrição detalhada.
- **Contact**: Informações de contato do desenvolvedor responsável.
- **ExternalDocumentation**: Adiciona links externos, como o repositório do GitHub.

### Principais Configurações
- **Título**: "SGE - Sistema de Gerenciamento Escolar"
- **Versão**: "1.0.0"
- **Contato**: Rafael Vitor de Oliveira (LinkedIn e e-mail)
- **Link Externo**: Repositório no GitHub

Essa configuração permite que a API tenha uma interface gráfica e documentação acessível via `/swagger-ui.html` ou outros endpoints configurados pelo Swagger.

---

## WebConfig.java

### Descrição
A classe `WebConfig` contém a configuração de CORS (Cross-Origin Resource Sharing) para permitir que a API seja acessada por clientes front-end hospedados em diferentes domínios. Ela define quais origens, métodos HTTP e cabeçalhos são permitidos ao acessar os serviços da API.

### Anotações
- `@Configuration`: Indica que essa classe contém definições de configuração do Spring.

### Métodos
- **addCorsMappings(CorsRegistry registry)**: Configura as permissões de CORS para toda a aplicação. Especifica que qualquer rota (`/**`) pode ser acessada pela origem `http://localhost:3000` (ideal para desenvolvimento com React ou outras interfaces web hospedadas localmente).
  - **allowedOrigins**: Permite a origem `http://localhost:3000`.
  - **allowedMethods**: Especifica os métodos HTTP permitidos: `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS`.
  - **allowedHeaders**: Permite todos os cabeçalhos (`*`).
  - **allowCredentials**: Indica que as credenciais, como cookies, podem ser incluídas nas requisições.

Essa configuração é especialmente útil durante o desenvolvimento, permitindo que um front-end local interaja com a API sem problemas de bloqueio por CORS.

---

## Conclusão
O package de configuração é essencial para o funcionamento da aplicação e para garantir que os componentes fundamentais estejam bem integrados e prontos para serem utilizados. A classe `Pi3MediotecApplication` é o ponto de entrada principal da aplicação, iniciando o contexto Spring. A `SwaggerConfig` oferece uma documentação interativa para que os desenvolvedores possam explorar e testar as APIs facilmente. Por fim, `WebConfig` garante que as requisições entre o front-end e o back-end possam ser feitas com permissões adequadas via CORS.

---


# Capítulo 3 - Configurações da Aplicação

Este capítulo aborda as configurações essenciais da aplicação, detalhando como o arquivo `application.properties` e o `pom.xml` estruturam o comportamento do sistema. Ambos são fundamentais para o correto funcionamento da aplicação Spring Boot, fornecendo propriedades de configuração e dependências necessárias para rodar o sistema.

## Configurações do `application.properties`

O arquivo `application.properties` é o local onde são definidas as propriedades que configuram o comportamento do sistema. Ele contém configurações de conexão com o banco de dados, parâmetros do Hibernate, configurações regionais, e mais. Abaixo, são descritas as principais configurações utilizadas neste projeto.

### 1. Configuração Básica da Aplicação

```properties
spring.application.name=pi3-mediotec
```

**Descrição**: Define o nome da aplicação Spring Boot, neste caso, "pi3-mediotec". Esse nome pode ser usado em logs ou para identificar a aplicação em ambientes distribuídos.

### 2. Configurações do Banco de Dados

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/pi3_mediotec?createDatabaseIfNotExist=true
spring.datasource.username= <nome do usuario>
spring.datasource.password= <senha>
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

- **spring.datasource.url**: Define a URL de conexão com o banco de dados MySQL. Aqui, a aplicação se conecta ao banco `pi3_mediotec` na porta 3306 do `localhost`. O parâmetro `createDatabaseIfNotExist=true` assegura que o banco seja criado automaticamente se ainda não existir.
- **spring.datasource.username**: Nome de `usuário` do banco de dados.
- **spring.datasource.password**: `Senha` do banco de dados.
- **spring.datasource.driver-class-name**: Classe do driver JDBC responsável por gerenciar a conexão com o MySQL, neste caso, `com.mysql.cj.jdbc.Driver`.

### 3. Configurações do Hibernate

```properties
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
```

- **spring.jpa.properties.hibernate.dialect**: Define o dialeto SQL que o Hibernate deve usar ao interagir com o banco de dados. No caso do MySQL, o dialeto padrão é `org.hibernate.dialect.MySQLDialect`, que permite ao Hibernate gerar queries SQL compatíveis com este banco.
- **spring.jpa.hibernate.ddl-auto**: Configura como o Hibernate deve lidar com o esquema do banco de dados:
  - `update`: O Hibernate atualiza o esquema de banco de dados existente com base nas entidades mapeadas na aplicação, sem perder dados. É útil para desenvolvimento, mas deve ser usado com cuidado em produção.
- **spring.jpa.show-sql**: Ativa o log de todas as queries SQL geradas pelo Hibernate no console.
- **spring.jpa.properties.hibernate.format_sql**: Formata as queries SQL no log para facilitar a leitura.
- **spring.jpa.properties.hibernate.show_sql**: Um complemento de `spring.jpa.show-sql`, que permite visualizar as queries SQL geradas.
- **spring.jpa.properties.hibernate.use_sql_comments**: Adiciona comentários nas queries SQL para auxiliar no entendimento de qual parte da aplicação originou a query.

### 4. Configurações Regionais e de Fuso Horário

```properties
spring.jackson.time-zone=America/Sao_Paulo
spring.messages.basename=messages
```

- **spring.jackson.time-zone**: Define o fuso horário para a serialização de datas. Aqui, a aplicação está configurada para o fuso horário de "America/Sao_Paulo", garantindo que todas as transações de tempo estejam ajustadas para o horário de Brasília.
- **spring.messages.basename**: Define o local onde o Spring Boot buscará arquivos de mensagens internacionalizadas. Por exemplo, arquivos `messages.properties` podem conter mensagens e validações em vários idiomas.

### 5. Configuração do Swagger UI

```properties
springdoc.swagger-ui.path=/swagger-ui.html
```

- **springdoc.swagger-ui.path**: Define o caminho onde a interface Swagger UI será acessível. Neste caso, o Swagger estará disponível no endpoint `/swagger-ui.html`. Essa interface é essencial para visualizar e testar as APIs expostas pela aplicação de forma interativa.

## Conclusão

O arquivo `application.properties` desempenha um papel fundamental na configuração de vários aspectos da aplicação. Ele define a conexão com o banco de dados, configurações do Hibernate para mapear entidades e gerenciar o banco de dados, ajustes de fuso horário, internacionalização, e a integração com o Swagger para documentação da API. Ajustar essas propriedades corretamente garante que a aplicação funcione adequadamente em diferentes ambientes, desde o desenvolvimento até a produção.


---


# Configurações do pom.xml

O arquivo `pom.xml` (Project Object Model) é um dos principais arquivos de configuração de projetos no Maven. Ele descreve as informações do projeto, gerencia as dependências necessárias e configura os plugins usados no ciclo de vida do projeto. Para projetos baseados em Spring Boot, como o presente, o `pom.xml` também é utilizado para configurar a versão do Java, bibliotecas adicionais, e comportamentos durante a compilação e execução da aplicação.

## Estrutura do pom.xml

O arquivo é dividido em várias seções importantes:

- `<modelVersion>`: Define a versão do modelo POM usada.
- `<parent>`: Define o projeto pai, que neste caso é o Spring Boot Starter Parent. Ele herda propriedades e dependências de configuração comuns aos projetos Spring Boot.

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.2</version>
</parent>
```

O Spring Boot Starter Parent facilita o gerenciamento de versões e configurações padrão, incluindo dependências essenciais para uma aplicação Spring Boot.

### Informações do Projeto

- **`<groupId>`**: Representa o grupo ao qual o projeto pertence. No caso, `projeto.integrador.3.senac.mediotec`.
- **`<artifactId>`**: Nome único do projeto, neste caso, `pi3-mediotec`.
- **`<version>`**: Versão atual do projeto.
- **`<name>`** e **`<description>`**: Definem o nome e uma breve descrição do projeto.

### Propriedades

```xml
<properties>
    <java.version>17</java.version>
</properties>
```

Define a versão do Java utilizada no projeto. Aqui, a aplicação está configurada para usar o Java 17.

### Dependências

As dependências são bibliotecas e frameworks externos que a aplicação precisa para funcionar corretamente. O Maven baixa essas dependências automaticamente e as inclui no projeto. Abaixo estão listadas e explicadas as dependências presentes no `pom.xml`:

#### SpringDoc OpenAPI

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.1.0</version>
</dependency>
```

Descrição: Adiciona suporte à documentação automática de APIs usando Swagger e OpenAPI. Proporciona uma interface gráfica interativa para testar e visualizar os endpoints da aplicação.

#### Spring Boot Validation

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

Descrição: Fornece mecanismos de validação de dados (como tamanho de strings e validação de emails) para as entidades e DTOs da aplicação, usando anotações como `@NotNull`, `@Email`, e `@Size`.

#### Spring Boot Data JPA

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

Descrição: Inclui todas as funcionalidades do JPA (Java Persistence API) para facilitar o mapeamento objeto-relacional e persistência de dados em bancos de dados relacionais. Permite a integração com Hibernate e a criação de repositórios.

#### Spring Boot Web

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Descrição: Inclui as dependências necessárias para a criação de aplicações web usando Spring MVC. Oferece suporte para o desenvolvimento de APIs RESTful.

#### Spring Boot DevTools

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

Descrição: Fornece ferramentas de desenvolvimento, como recarregamento automático da aplicação e configuração simplificada de cache para acelerar o desenvolvimento.

#### MySQL Connector

```xml
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
```

Descrição: Driver JDBC para conectar a aplicação ao banco de dados MySQL.

#### PostgreSQL Driver

```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
```

Descrição: Driver JDBC para conectar a aplicação ao banco de dados PostgreSQL.

#### Lombok

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

Descrição: Biblioteca que reduz o boilerplate (código repetitivo) em classes Java, como getters, setters, construtores e métodos `equals` e `hashCode`. Facilita a criação de código mais enxuto.

#### Spring Boot Starter Test

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

Descrição: Conjunto de dependências para testes de unidade e integração no Spring Boot, incluindo bibliotecas como JUnit, Mockito, e Spring Test.

### Plugins

Os plugins são utilizados pelo Maven para realizar tarefas específicas, como compilação, empacotamento e execução de testes.

#### Spring Boot Maven Plugin

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```

Descrição: Facilita a criação de arquivos JAR e WAR executáveis. Também fornece funcionalidades úteis para rodar e empacotar a aplicação Spring Boot.

## Conclusão

O arquivo `pom.xml` é essencial para o gerenciamento do projeto Spring Boot, permitindo a inclusão de bibliotecas e frameworks necessários, além de configurar o ciclo de vida da aplicação com plugins e dependências. Cada uma das dependências mencionadas desempenha um papel fundamental no funcionamento correto da aplicação, desde a persistência de dados até a documentação e teste das APIs.


---


# Capítulo 4 - Documentação do Banco de Dados

## 1. Introdução

Este banco de dados é o núcleo de um Sistema de Gerenciamento Escolar, contendo informações sobre alunos, professores, disciplinas, coordenadores, responsáveis, e outras entidades relacionadas ao ambiente acadêmico. Cada tabela e relacionamento foi modelado para otimizar a integração entre professores, alunos e coordenadores, além de armazenar dados como presenças, notas, horários e comunicação interna.

## 2. Tabelas

### 2.1 Tabela aluno

| Campo                     | Tipo      | Chave     |
|----------------------------|-----------|-----------|
| matricula_aluno             | PK        |           |
| nome                       | string    |           |
| ultimo_nome                | string    |           |
| data_nascimento            | date      |           |
| genero                     | string    |           |
| cpf                        | string    | Unique    |
| email                      | string    | Unique    |
| status                     | bit       |           |
| coordenacao_id_coordenacao | FK        |           |
| Relationships               |           |           |
| aluno_turma                | N:N       |           |
| responsavel                | 1:N       |           |
| presenca                   | 1:N       |           |
| conceito                   | 1:N       |           |


A tabela aluno armazena as informações dos alunos matriculados no sistema. Ela possui os seguintes campos:

- **matricula_aluno**: Chave primária auto-incrementável.
- **nome**: Nome do aluno.
- **ultimo_nome**: Sobrenome do aluno.
- **data_nascimento**: Data de nascimento.
- **genero**: Gênero do aluno.
- **cpf**: Número do CPF (único).
- **email**: Email do aluno (único).
- **status**: Status de ativo/inativo (bit).
- **coordenacao_id_coordenacao**: Chave estrangeira para a tabela coordenacao.

#### Relacionamentos:

- **aluno_turma**: Relaciona alunos com turmas (relacionamento N:N).
- **responsavel**: Um aluno pode ter um ou mais responsáveis.
- **presenca**: Relação com as presenças dos alunos em suas aulas.
- **conceito**: Notas e conceitos relacionados ao aluno.

### 2.2 Tabela professor

| Campo        | Tipo      | Chave     |
|--------------|-----------|-----------|
| cpf          | PK        |           |
| nome         | string    |           |
| ultimo_nome  | string    |           |
| data_nascimento | date   |           |
| email        | string    | Unique    |
| genero       | string    |           |
| status       | bit       |           |
| id_coordenacao| FK       |           |
| Relationships |           |           |
| turma_disciplina_professor | N:N     |           
| comunicado   | 1:N       |           |



A tabela professor armazena os dados dos professores:

- **cpf**: Chave primária e CPF do professor.
- **nome**: Nome do professor.
- **ultimo_nome**: Sobrenome do professor.
- **data_nascimento**: Data de nascimento do professor.
- **email**: Endereço de email (único).
- **genero**: Gênero do professor.
- **status**: Status de atividade (bit).
- **id_coordenacao**: Chave estrangeira para a tabela coordenacao.

#### Relacionamentos:

- **turma_disciplina_professor**: Relaciona professores com disciplinas e turmas.
- **comunicado**: Permite que professores enviem comunicados.

### 2.3 Tabela disciplina

| Campo          | Tipo      | Chave     |
|----------------|-----------|-----------|
| id_disciplina  | PK        |           |
| nome           | string    |           |
| carga_horaria  | int       |           |
| Relationships  |           |           |
| turma_disciplina_professor | N:N       |           
| conceito       | 1:N       |           |
| horario        | 1:N       |           |

A tabela disciplina contém as disciplinas oferecidas no sistema:

- **id_disciplina**: Chave primária auto-incrementável.
- **nome**: Nome da disciplina.
- **carga_horaria**: Carga horária total da disciplina.

#### Relacionamentos:

- **turma_disciplina_professor**: Relaciona disciplinas com turmas e professores.
- **conceito**: Registra notas dos alunos para cada disciplina.
- **horario**: Define os horários de aulas para cada disciplina.

### 2.4 Tabela turma

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| id_turma      | PK        |           |
| nome          | string    |           |
| ano_letivo    | int       |           |
| ano_escolar   | string    |           |
| turno         | string    |           |
| status        | bit       |           |
| id_coordenacao| FK        |           |
| Relationships |           |           |
| aluno_turma   | N:N       |           |
| turma_disciplina_professor | N:N      |   

A tabela turma representa as turmas cadastradas no sistema:

- **id_turma**: Chave primária auto-incrementável.
- **nome**: Nome da turma.
- **ano_letivo**: Ano letivo da turma.
- **ano_escolar**: Ano escolar (por exemplo, 1º ano, 2º ano, etc.).
- **turno**: Turno da turma (matutino, vespertino, etc.).
- **status**: Status de atividade (bit).
- **id_coordenacao**: Chave estrangeira para a tabela coordenacao.

#### Relacionamentos:

- **aluno_turma**: Relaciona alunos com turmas.
- **turma_disciplina_professor**: Relaciona turmas com disciplinas e professores.

### 2.5 Tabela responsavel

| Campo        | Tipo      | Chave     |
|--------------|-----------|-----------|
| id           | PK        |           |
| cpf          | string    | Unique    |
| nome         | string    |           |
| ultimo_nome  | string    |           |
| grau_parentesco | string  |           |
| aluno_id     | FK        |           |
| Relationships|           |           |
| aluno        | N:1       |           |

Armazena os responsáveis pelos alunos, com informações como nome, CPF, e grau de parentesco:

- **id**: Chave primária auto-incrementável.
- **cpf**: CPF do responsável (único).
- **nome**: Nome do responsável.
- **ultimo_nome**: Sobrenome do responsável.
- **grau_parentesco**: Grau de parentesco com o aluno.
- **aluno_id**: Chave estrangeira para a tabela aluno.

### 2.6 Tabela telefone

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| id            | PK        |           |
| ddd           | int       |           |
| numero        | string    |           |
| aluno_id      | FK        |           |
| professor_id  | FK        |           |
| coordenador_id| FK        |           |
| responsavel_id| FK        |           |

Armazena os números de telefone associados a alunos, professores, coordenadores e responsáveis:

- **id**: Chave primária auto-incrementável.
- **ddd**: Código de área do telefone (2 dígitos).
- **numero**: Número do telefone.
- **aluno_id**: Chave estrangeira para a tabela aluno.
- **professor_id**: Chave estrangeira para a tabela professor.
- **coordenador_id**: Chave estrangeira para a tabela coordenador.
- **responsavel_id**: Chave estrangeira para a tabela responsavel.

### 2.7 Tabela coordenacao

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| id_coordenacao| PK        |           |
| nome          | string    |           |
| descricao     | string    |           |


Armazena as coordenações dentro da instituição:

- **id_coordenacao**: Chave primária auto-incrementável.
- **nome**: Nome da coordenação.
- **descricao**: Breve descrição da coordenação.

### 2.8 Tabela turma_disciplina_professor

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| id_disciplina | FK        |           |
| id_professor  | FK        |           |
| id_turma      | FK        |           |

Essa tabela é intermediária e realiza a associação entre turmas, disciplinas e professores:

- **id_disciplina**: Chave estrangeira para a tabela disciplina.
- **id_professor**: Chave estrangeira para a tabela professor.
- **id_turma**: Chave estrangeira para a tabela turma.

### 2.9 Tabela conceito

| Campo          | Tipo      | Chave     |
|----------------|-----------|-----------|
| id_conceito    | PK        |           |
| id_aluno       | FK        |           |
| id_disciplina  | FK        |           |
| id_professor   | FK        |           |
| id_turma       | FK        |           |
| media_final    | float     |           |
| nota_unidade1  | float     |           |
| nota_unidade2  | float     |           |
| nota_unidade3  | float     |           |
| nota_unidade4  | float     |           |
| noa1           | float     |           |
| noa2           | float     |           |
| noa_final      | float     |           |

Registra as notas e avaliações (conceitos) dos alunos em suas disciplinas:

- **id_conceito**: Chave primária auto-incrementável.
- **id_aluno**: Chave estrangeira para a tabela aluno.
- **id_disciplina**: Chave estrangeira para a tabela disciplina.
- **id_professor**: Chave estrangeira para a tabela professor.
- **id_turma**: Chave estrangeira para a tabela turma.
- **media_final**: Média final do aluno na disciplina.
- **nota_unidade1** até **nota_unidade4**: Notas das quatro unidades avaliadas.
- **noa1**, **noa2**, **noa_final**: Notas de recuperação e exame final.

### 2.10 Tabela presenca

| Campo          | Tipo      | Chave     |
|----------------|-----------|-----------|
| id_presenca    | PK        |           |
| data           | date      |           |
| presenca       | bool      |           |
| id_aluno       | FK        |           |
| id_disciplina  | FK        |           |
| id_professor   | FK        |           |
| id_turma       | FK        |           |

Registra a presença dos alunos nas aulas:

- **id_presenca**: Chave primária auto-incrementável.
- **data**: Data da aula.
- **presenca**: Booleano que indica se o aluno estava presente.
- **id_aluno**: Chave estrangeira para a tabela aluno.
- **id_disciplina**: Chave estrangeira para a tabela disciplina.
- **id_professor**: Chave estrangeira para a tabela professor.
- **id_turma**: Chave estrangeira para a tabela turma.

### 2.11 Tabela horario


| Campo          | Tipo      | Chave     |
|----------------|-----------|-----------|
| id_horario     | PK        |           |
| dia_semana     | string    |           |
| hora_inicio    | time      |           |
| hora_fim       | time      |           |
| id_disciplina  | FK        |           |
| id_professor   | FK        |           |
| id_turma       | FK        |           |

Define os horários de aula para as turmas:

- **id_horario**: Chave primária auto-incrementável.
- **dia_semana**: Dia da semana (enum).
- **hora_inicio**: Hora de início da aula.
- **hora_fim**: Hora de término da aula.
- **id_disciplina**: Chave estrangeira para a tabela disciplina.
- **id_professor**: Chave estrangeira para a tabela professor.
- **id_turma**: Chave estrangeira para a tabela turma.

### 2.12 Tabela comunicado

| Campo                    | Tipo          | Chave     |
|---------------------------|---------------|-----------|
| id                        | PK            |           |
| conteudo                  | string        |           |
| data_envio                | datetime      |           |
| remetente_coordenacao_id   | FK            |           |
| remetente_professor_id     | FK            |           |

Armazena os comunicados enviados entre professores, coordenações, alunos e turmas:

- **id**: Chave primária auto-incrementável.
- **conteudo**: Conteúdo do comunicado.
- **data_envio**: Data e hora do envio do comunicado.
- **remetente_coordenacao_id**: Chave estrangeira para a tabela coordenacao.
- **remetente_professor_id**: Chave estrangeira para a tabela professor.

### 2.13 Tabela comunicado_receptor_alunos e comunicado_receptor_turmas

#### Comunicado_Receptor_Alunos

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| comunicado_id | FK        |           |
| aluno_id      | FK        |           |

#### Comunicado_Receptor_Turmas

| Campo         | Tipo      | Chave     |
|---------------|-----------|-----------|
| comunicado_id | FK        |           |
| turma_id      | FK        |           |

Relacionam os comunicados com os alunos e turmas que os receberam:

- **comunicado_id**: Chave estrangeira para a tabela comunicado.
- **aluno_id**: Chave estrangeira para a tabela aluno (na tabela comunicado_receptor_alunos).
- **turma_id**: Chave estrangeira para a tabela turma (na tabela comunicado_receptor_turmas).

## 3. Relacionamentos Principais

- **Aluno e Turma**: Relacionamento N:N através da tabela `aluno_turma`.
- **Turma, Disciplina e Professor**: Relacionamento N:N através da tabela intermediária `turma_disciplina_professor`.
- **Conceito**: Armazena as notas de cada aluno para suas disciplinas e turmas.
- **Presença**: Registra se os alunos estavam presentes nas aulas.
- **Comunicados**: Professores e coordenações podem enviar comunicados para alunos e turmas.


---


# Capítulo 5 - Endpoints

## Introdução
Esta seção apresenta os principais endpoints de cadastro e consulta do SGE (Sistema de Gerenciamento Escolar). Para uma documentação completa de todos os endpoints disponíveis, incluindo parâmetros, respostas e exemplos, acesse o Swagger da API:

**Swagger UI**: [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)

A seguir, são apresentados os exemplos de requisições POST (cadastro mínimo e máximo) e GET (consulta detalhada) para cada entidade do sistema.

## 1. Aluno
**Campos mínimos**:
- Nome
- Último nome
- Gênero
- Data de nascimento
- Email
- CPF
- Responsável (ID do responsável)

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "João",
  "ultimoNome": "Silva",
  "genero": "Masculino",
  "data_nascimento": "2005-05-10",
  "email": "joao.silva@email.com",
  "cpf": "123.456.789-00",
  "responsavel": {
    "nome": "Carlos",
    "ultimoNome": "Silva",
    "cpf": "321.654.987-00",
    "grauParentesco": "Pai"
  }
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "João",
  "ultimoNome": "Silva",
  "genero": "Masculino",
  "data_nascimento": "2005-05-10",
  "email": "joao.silva@email.com",
  "cpf": "123.456.789-00",
  "responsavel": {
    "nome": "Carlos",
    "ultimoNome": "Silva",
    "cpf": "321.654.987-00",
    "grauParentesco": "Pai",
    "telefones": [
      {
        "ddd": "81",
        "numero": "999999999"
      }
    ]
  },
  "enderecos": [
    {
      "cep": "50000-000",
      "rua": "Rua A",
      "numero": "123",
      "bairro": "Centro",
      "cidade": "Recife",
      "estado": "PE"
    }
  ],
  "turmasIds": [1, 2]
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "nome": "João",
  "ultimoNome": "Silva",
  "genero": "Masculino",
  "data_nascimento": "2005-05-10",
  "email": "joao.silva@email.com",
  "cpf": "123.456.789-00",
  "status": true,
  "responsavel": {
    "nome": "Carlos",
    "ultimoNome": "Silva",
    "cpf": "321.654.987-00",
    "grauParentesco": "Pai"
  },
  "enderecos": [
    {
      "cep": "50000-000",
      "rua": "Rua A",
      "numero": "123",
      "bairro": "Centro",
      "cidade": "Recife",
      "estado": "PE"
    }
  ],
  "turmas": [
    {
      "nome": "Turma A",
      "anoLetivo": 2024,
      "anoEscolar": "1º Ano"
    }
  ]
}
```

## 2. Professor
**Campos mínimos**:
- Nome
- Último nome
- Gênero
- Data de nascimento
- Email
- CPF

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "Maria",
  "ultimoNome": "Fernandes",
  "genero": "Feminino",
  "data_nascimento": "1980-03-12",
  "email": "maria.fernandes@email.com",
  "cpf": "987.654.321-00"
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "Maria",
  "ultimoNome": "Fernandes",
  "genero": "Feminino",
  "data_nascimento": "1980-03-12",
  "email": "maria.fernandes@email.com",
  "cpf": "987.654.321-00",
  "enderecos": [
    {
      "cep": "50000-000",
      "rua": "Rua B",
      "numero": "321",
      "bairro": "Boa Vista",
      "cidade": "Recife",
      "estado": "PE"
    }
  ],
  "telefones": [
    {
      "ddd": "81",
      "numero": "988888888"
    }
  ],
  "turmasDisciplinas": [
    {
      "turmaId": 1,
      "disciplinasIds": [1]
    }
  ]
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "cpf": "987.654.321-00",
  "nome": "Maria",
  "ultimoNome": "Fernandes",
  "genero": "Feminino",
  "data_nascimento": "1980-03-12",
  "email": "maria.fernandes@email.com",
  "status": true,
  "enderecos": [
    {
      "cep": "50000-000",
      "rua": "Rua B",
      "numero": "321",
      "bairro": "Boa Vista",
      "cidade": "Recife",
      "estado": "PE"
    }
  ],
  "telefones": [
    {
      "ddd": "81",
      "numero": "988888888"
    }
  ],
  "coordenacao": {
    "nome": "Coordenação de Exatas",
    "coordenadores": [
      {
        "nomeCoordenador": "Carlos Silva",
        "email": "carlos.silva@email.com"
      }
    ]
  },
  "turmas": [
    {
      "nome": "Turma A",
      "anoLetivo": 2024,
      "anoEscolar": "1º Ano",
      "disciplinas": [
        {
          "nome": "Matemática"
        }
      ]
    }
  ]
}
```

## 3. Coordenação
**Campos mínimos**:
- Nome
- ID do Coordenador

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "Coordenação de Ciências",
  "coordenadorId": "98765432100"
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "Coordenação de Ciências",
  "descricao": "Coordenação responsável pelas disciplinas de ciências naturais",
  "coordenadorId": "98765432100"
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "nome": "Coordenação de Ciências",
  "descricao": "Coordenação responsável pelas disciplinas de ciências naturais",
  "coordenadores": [
    {
      "nomeCoordenador": "Carlos Silva",
      "email": "carlos.silva@email.com"
    }
  ]
}
```

## 4. Disciplina
**Campos mínimos**:
- Nome
- Carga horária

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "Matemática",
  "carga_horaria": 80
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "Matemática",
  "carga_horaria": 80
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "nome": "Matemática",
  "carga_horaria": 80,
  "turmas": [
    {
      "nome": "Turma A",
      "anoLetivo": 2024,
      "anoEscolar": "1º Ano"
    }
  ],
  "professores": [
    {
      "cpf": "987.654.321-00",
      "nome": "Maria Fernandes"
    }
  ]
}
```

## 5. Turma
**Campos mínimos**:
- Nome
- Ano letivo
- Ano escolar
- Turno

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "Turma A",
  "anoLetivo": 2024,
  "anoEscolar": "1º Ano",
  "turno": "Matutino"
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "Turma A",
  "anoLetivo": 2024,
  "anoEscolar": "1º Ano",
  "turno": "Matutino",
  "alunosIds": [1, 2],
  "disciplinasProfessores": [
    {
      "professorId": "98765432100",
      "disciplinasIds": [1]
    }
  ]
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "nome": "Turma A",
  "anoLetivo": 2024,
  "anoEscolar": "1º Ano",
  "turno": "Matutino",
  "disciplinas": [
    {
      "nome": "Matemática",
      "professores": [
        {
          "nome": "Maria Fernandes",
          "email": "maria.fernandes@email.com"
        }
      ]
    }
  ],
  "alunos": [
    {
      "nomeAluno": "João Silva",
      "email": "joao.silva@email.com"
    }
  ]
}
```

## 6. Responsável
**Campos mínimos**:
- Nome
- Último nome
- CPF
- Grau de parentesco

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "nome": "Carlos",
  "ultimoNome": "Oliveira",
  "cpf": "321.654.987-00",
  "grauParentesco": "Pai"
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "nome": "Carlos",
  "ultimoNome": "Oliveira",
  "cpf": "321.654.987-00",
  "grauParentesco": "Pai",
  "telefones": [
    {
      "ddd": "81",
      "numero": "999999999"
    }
  ]
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "nome": "Carlos",
  "ultimoNome": "Oliveira",
  "cpf": "321.654.987-00",
  "grauParentesco": "Pai",
  "telefones": [
    {
      "ddd": "81",
      "numero": "999999999"
    }
  ],
  "alunos": [
    {
      "nomeAluno": "João Silva",
      "email": "joao.silva@email.com"
    }
  ]
}
```

## 7. Conceito
**Campos mínimos**:
- ID do Aluno
- ID da Disciplina
- ID da Turma
- Conceito final (aprovado ou reprovado)

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "idProfessor": 1,
  "idAluno": 1,
  "idDisciplina": 1,
  "idTurma": 1,
  "conceito_final": "Aprovado"
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "idProfessor": 1,
  "idAluno": 1,
  "idDisciplina": 1,
  "idTurma": 1,
  "conceito_final": "Aprovado",
  "nota_unidade1": 8.0,
  "nota_unidade2": 9.0,
  "media_final": 8.5
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "aluno": {
    "nome": "João Silva",
    "email": "joao.silva@email.com"
  },
  "disciplina": {
    "nome": "Matemática"
  },
  "turma": {
    "nome": "Turma A",
    "anoLetivo": 2024
  },
  "conceito_final": "Aprovado",
  "media_final": 8.5,
  "nota_unidade1": 8.0,
  "nota_unidade2": 9.0
}
```

## 8. Comunicado
**Campos mínimos**:
- Conteúdo do comunicado
- Data de envio
- Remetente (ID da coordenação ou professor)

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "conteudo": "Reunião importante na próxima segunda-feira.",
  "data_envio": "2024-09-21T14:30:00",
  "remetenteCoordenacaoId": 1
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "conteudo": "Reunião importante na próxima segunda-feira.",
  "data_envio": "2024-09-21T14:30:00",
  "remetenteCoordenacaoId": 1,
  "receptores": {
    "alunosIds": [1, 2],
    "turmasIds": [1]
  }
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "conteudo": "Reunião importante na próxima segunda-feira.",
  "data_envio": "2024-09-21T14:30:00",
  "remetente": {
    "nome": "Coordenação de Ciências"
  },
  "receptores": {
    "alunos": [
      {
        "nomeAluno": "João Silva",
        "email": "joao.silva@email.com"
      }
    ],
    "turmas": [
      {
        "nome": "Turma A",
        "anoLetivo": 2024
      }
    ]
  }
}
```

## 9. Presenca

**Campos mínimos**:
- ID do Aluno
- ID da Disciplina
- ID da Turma
- ID do Professor
- Data da presença
- Status de presença (presente ou ausente)

### Exemplo de cadastro (POST - Mínimo):
```json
{
  "idAluno": 1,
  "idDisciplina": 1,
  "idTurma": 1,
  "idProfessor": "123456789",
  "data": "2024-09-22",
  "presenca": true
}
```

### Exemplo de cadastro (POST - Máximo):
```json
{
  "idAluno": 1,
  "idDisciplina": 1,
  "idTurma": 1,
  "idProfessor": "123456789",
  "data": "2024-09-22",
  "presenca": true
}
```

### Exemplo de consulta (GET - Completo):
```json
{
  "aluno": {
    "nomeAluno": "João Silva",
    "email": "joao.silva@email.com"
  },
  "disciplina": {
    "nome": "Matemática"
  },
  "turma": {
    "nome": "Turma A",
    "anoLetivo": 2024,
    "anoEscolar": "1º ano",
    "turno": "Manhã"
  },
  "professor": {
    "nomeProfessor": "Maria Oliveira",
    "email": "maria.oliveira@email.com"
  },
  "data": "2024-09-22",
  "presenca": true
}
```


---


# Capítulo 6 - Em Desenvolvimento (futuras melhorias)

Com o desenvolvimento contínuo do Sistema de Gerenciamento Escolar (SGE), novas funcionalidades e aprimoramentos serão necessários para melhorar sua robustez, segurança e escalabilidade. Abaixo estão algumas das melhorias planejadas para futuras versões do sistema:

## 1. Tratamento de Erros Mais Robustos

Atualmente, o tratamento de erros é funcional, porém, há espaço para melhorias. Pretende-se implementar uma camada de tratamento de erros mais robusta, que incluirá:

- Validações mais detalhadas nas entradas e saídas do sistema.
- Mensagens de erro padronizadas, que facilitem a identificação e resolução de problemas pelos usuários e desenvolvedores.
- Logger aprimorado para capturar detalhes completos dos erros no sistema, ajudando na auditoria e na correção de bugs.

## 2. Encapsulamento da Regra de Negócio

Para aumentar a manutenção e reutilização de código, as regras de negócio serão completamente encapsuladas dentro de serviços especializados. Isso trará:

- Separação clara entre regras de negócio e a lógica de apresentação.
- Reuso de lógica em diferentes partes do sistema, evitando duplicação de código.
- Facilidade de testes unitários e de integração, garantindo a confiabilidade das operações críticas.

## 3. Configuração Mais Forte das Bilateralidades

Pretendemos revisar e fortalecer os relacionamentos bidirecionais (Many-to-Many, One-to-Many) no sistema, incluindo:

- Validação das bilateralidades em operações de persistência, para garantir a integridade dos relacionamentos entre entidades.
- Implementação de métodos auxiliares para garantir que os relacionamentos entre entidades sejam corretamente gerenciados e sincronizados.
- Documentação aprimorada das bilateralidades, detalhando como as entidades se inter-relacionam no sistema.

## 4. Implementação de Spring Security

A segurança do sistema será aprimorada com a integração do Spring Security. Esse framework fornecerá:

- **Autenticação**: Controle de acesso aos recursos, garantindo que apenas usuários autorizados possam acessar informações sensíveis.
- **Autorização baseada em papéis (roles)**: Definição de permissões para cada usuário ou grupo de usuários, como administradores, coordenadores, professores e alunos.
- Proteção contra ataques comuns, como CSRF (Cross-Site Request Forgery) e XSS (Cross-Site Scripting).

## 5. Auditoria e Logs de Atividade

Para aumentar a transparência e segurança, será implementado um sistema de auditoria que registre as ações dos usuários no sistema, incluindo:

- Logs detalhados de todas as operações CRUD realizadas pelos usuários.
- Relatórios de atividades, que permitirão verificar quem acessou ou modificou dados específicos.
- Integração com ferramentas de monitoramento de segurança, para detectar atividades suspeitas em tempo real.

## 6. Melhorias na Performance e Escalabilidade

Com o crescimento da base de dados, será essencial garantir a escalabilidade do sistema, por meio de:

- Otimização das consultas SQL para reduzir o tempo de resposta nas operações com grandes volumes de dados.
- Implementação de caching para reduzir o número de consultas ao banco de dados em operações repetitivas.
- Melhorias na infraestrutura de deploy, permitindo que o sistema suporte um maior número de usuários simultâneos sem perda de desempenho.

Essas futuras melhorias visam tornar o SGE mais robusto, seguro e escalável, garantindo a satisfação dos usuários e a longevidade do sistema.


### 7. Testes Automatizados

-  Adição de testes automatizados é uma melhoria significativa, implementar testes unitários e de integração com JUnit ou Mockito garantindo que o sistema se comporta conforme esperado, reduzindo a possibilidade de erros em atualizações futuras.
-  Criar testes para validar regras de negócio e integração entre os componentes.


### 8. Integração de APIs

- A integração com APIs externas será uma das próximas grandes etapas do sistema, permitindo que o **SGE** possa se comunicar com sistemas educacionais externos, como plataformas de ensino à distância, gerenciadores de conteúdo (LMS) e ferramentas de pagamento.
- Essa integração ampliará o alcance do sistema, tornando-o mais versátil e permitindo que ele atenda a uma gama mais ampla de necessidades institucionais.
- As APIs também trarão melhorias no compartilhamento de dados e funcionalidades, facilitando a automação de processos e a sincronia entre diferentes sistemas.


---


# Capítulo 7: Instalação, Uso e Dependências

## 1. Instruções de Instalação

Aqui estão os passos detalhados para instalar e executar o projeto. Siga as etapas com cuidado para garantir uma instalação bem-sucedida:

1. **Instalar Eclipse:**
   Baixe o Eclipse do link oficial:  
   [https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2024-09/R/eclipse-inst-jre-mac64.dmg](https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2024-09/R/eclipse-inst-jre-mac64.dmg).

2. **Instalar dependências adicionais:**
   Siga as instruções fornecidas no arquivo `dependencies.md` para instalar todas as dependências necessárias do projeto.

## 2. Instruções de Uso

1. **Abrir o Eclipse:**
   Depois de instalar o Eclipse, abra o aplicativo e importe o projeto baixado.

2. **Executar o Projeto:**
   Navegue até o diretório do projeto no Eclipse, clique com o botão direito no arquivo principal e selecione "Run As > Java Application" para iniciar a aplicação

3. **Configuração do `application.properties`:**

Para que o projeto funcione corretamente, é necessário configurar o arquivo `application.properties` com as informações de conexão com o banco de dados e outras variáveis de ambiente.

**Localização do arquivo:**  
O arquivo `application.properties` geralmente está localizado no diretório `src/main/resources/`. Se não encontrar, crie o arquivo com o mesmo nome e no mesmo diretório. Depois copie a configuração abaixo e cole no seu arquivo, colocando apenas o **nome do usuário** e a **senha** correspondente ao seu MySQL. 

### Exemplo de configuração do `application.properties`:

```application.properties
spring.application.name=pi3-mediotec
spring.datasource.url=jdbc:mysql://localhost:3306/pi3_mediotec?createDatabaseIfNotExist=true
spring.datasource.username= **<NOME DO USUÁRIO>**
spring.datasource.password= **<SENHA>**
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
# spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.hibernate.ddl-auto=update

spring.jpa.show-sql=true

spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jackson.time-zone=America/Sao_Paulo
spring.messages.basename=messages

springdoc.swagger-ui.path=/swagger-ui.html

```

### Configurar as variáveis de ambiente

Verifique se o seu ambiente local tem as variáveis corretas configuradas para a URL, o usuário e a senha do banco de dados.

Agora o arquivo `application.properties` está incluído na documentação, garantindo que as configurações necessárias sejam feitas corretamente.


## 3. Dependências do Projeto

O projeto requer as seguintes dependências para funcionar corretamente:

- **Java 11 ou superior:**  
  Certifique-se de que você tem o Java 11 ou superior instalado no seu sistema.

- **Spring Boot:**  
  O projeto usa o Spring Boot para facilitar a criação de aplicativos Java.

- **MySQL ou PostgreSQL:**  
  Dependendo do banco de dados escolhido, instale MySQL ou PostgreSQL no seu sistema.

- **Maven:**  
  O projeto utiliza o Maven para o gerenciamento de dependências. Certifique-se de que o Maven esteja instalado e configurado corretamente.

Para mais informações, consulte o arquivo `pom.xml` para uma lista completa das dependências e suas versões.

